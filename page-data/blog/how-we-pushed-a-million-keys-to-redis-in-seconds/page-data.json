{"componentChunkName":"component---src-templates-post-js","path":"/blog/how-we-pushed-a-million-keys-to-redis-in-seconds/","result":{"data":{"ghostPost":{"id":"Ghost__Post__5eafa30734df85001e15f489","title":"How We Pushed a Million Keys to Redis in Seconds","slug":"how-we-pushed-a-million-keys-to-redis-in-seconds","featured":false,"feature_image":"https://res-2.cloudinary.com/hcq4cvthp/image/upload/q_auto/v1/ghost-blog-images/1_gN5KGQcKSipjSlQqEppJMA.jpg","excerpt":"Dealing with a lot of keys? Redis’ Pipe Mode is your friend.\nHello there!\n\nIn this post, I’ll share my ideas on how we populated Redis (running in a\nKubernetes cluster)… in a matter of seconds.\n\nHere’s what can you expect from this post:\n\n1. How to connect to Redis server running in a Kubernetes cluster ?\n\n2. What is Port-forwarding ?\n\n3. How to use Redis mass insertion & push millions of keys in seconds ?\n\n4. How to generate Redis Protocol ?\n\n5. How to read /parse a CSV in Ruby ?\n\nWait, but why","custom_excerpt":null,"visibility":"public","created_at_pretty":"04 May, 2020","published_at_pretty":"04 May, 2020","updated_at_pretty":"12 May, 2020","created_at":"2020-05-04T10:37:19.000+05:30","published_at":"2020-05-04T10:45:13.000+05:30","updated_at":"2020-05-12T11:50:45.000+05:30","meta_title":"How We Pushed a Million Keys to Redis in Seconds","meta_description":"Dealing with a lot of keys? Redis’ Pipe Mode is your friend.","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Gojek","slug":"gojek","bio":null,"profile_image":null,"twitter":"@gojektech","facebook":null,"website":"http://www.gojek.io"}],"primary_author":{"name":"Gojek","slug":"gojek","bio":null,"profile_image":null,"twitter":"@gojektech","facebook":null,"website":"http://www.gojek.io"},"primary_tag":{"name":"Tech","slug":"tech","description":"Learnings from technical challenges solved at Gojek, how-tos, and programming tips.","feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Tech","slug":"tech","description":"Learnings from technical challenges solved at Gojek, how-tos, and programming tips.","feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"Dealing with a lot of keys? Redis’ Pipe Mode is your friend.\nHello there!\n\nIn this post, I’ll share my ideas on how we populated Redis (running in a\nKubernetes cluster)… in a matter of seconds.\n\nHere’s what can you expect from this post:\n\n1. How to connect to Redis server running in a Kubernetes cluster ?\n\n2. What is Port-forwarding ?\n\n3. How to use Redis mass insertion & push millions of keys in seconds ?\n\n4. How to generate Redis Protocol ?\n\n5. How to read /parse a CSV in Ruby ?\n\nWait, but why do I need to do this? ?\n\nAt Gojek, we use Redis in one of the services for caching drivers for faster\nlookups. Since we have deployed this service to new clusters, we needed to\npopulate Redis with ~81K keys.\n\nWhat we didn’t do (and should not be done)\nWell, this. ?\n\n$ redis-cli -h \"hostname\" -p 6379 set \"key\" \"value\"\n\nThis simple and easy way of storing a key through redis-cli\n[https://redis.io/topics/rediscli] is okay, but not for thousands or millions of\nkeys. You don’t want to end up waiting for hours unless you are Regina Phalange\n[https://en.wikipedia.org/wiki/Phoebe_Buffay#%22Regina_Phalange%22]! ?\n\nUsing a normal Redis client to perform mass insertion is not a good idea. The\nnaive approach of sending one command after the other is slow, because you have\nto pay for the round trip time for every command.\n\nLet’s do something different!\nWe will use Redis mass insertion, but before going to that, let’s talk a bit\nabout Redis Protocol [https://redis.io/topics/protocol].\n\nRedis clients communicate with the Redis server using a protocol called RESP \n(REdis Serialization Protocol).\n\nWith that said, let’s go write some code! I like toying around with Ruby\n[https://www.ruby-lang.org/en/], so this was my language of choice.\n\nredis_mass_insert.rbgen_redis_proto function will generate the protocol required for mass insertion.\n\n> 2.6.3 > puts gen_redis_proto(\"SET\",\"mykey\",\"Hello World!\").inspect\nRunning the above command in Ruby console, will give us the following protocol.\n\n\"*3\\r\\n$3\\r\\nSET\\r\\n$5\\r\\nmykey\\r\\n$12\\r\\nHello World!\\r\\n\"\n\nWell, this is how a command is represented and sent to the Redis Server through \nRedis Protocol [https://redis.io/topics/protocol].\n\n*<args><cr><lf>\n$<len><cr><lf>\n<arg0><cr><lf>\n<arg1><cr><lf>\n...\n<argN><cr><lf>\n\nWhere <cr> means \"\\r\" (or ASCII character 13) and <lf> means \"\\n\" (or ASCII\ncharacter 10).\n\nWe can now run this script, but here’s a catch. Our Redis server runs in a\nKubernetes cluster and we didn’t want to install Ruby and its gems inside a\ncluster. So now?\n\nEnter port-forwarding! ?\n$ kubectl -n \"namespace\" port-forward \"pod-name\" 7000:6379\n\nConnections made to local port 7000 are forwarded to port 6379 of the pod that\nis running the Redis server. With this connection in place we can use our local\nworkstation to debug the database that is running in the pod.\n\nFinally, we run our script to populate Redis ?\n\n> $ ruby redis_mass_insert.rb | redis-cli -p 7000 --pipe\n> All data transferred. Waiting for the last reply...\nLast reply received from server.\nerrors: 0, replies: 81003\nWe ran this script and it completed within a fraction of seconds!\n\nBut, how?\nIn 2.6 or later versions of Redis the redis-cli utility supports a new mode\ncalled pipe mode that was designed in order to perform mass insertion.\n\nUnder the hood of pipe mode\nAccording to the official doc:\n\n * redis-cli — pipe tries to send data as fast as possible to the server.\n * At the same time it reads data when available, trying to parse it.\n * Once there is no more data to read from stdin, it sends a special ECHO \n   command with a random 20 bytes string: we are sure this is the latest command\n   sent, and we are sure we can match the reply checking if we receive the same\n   20 bytes as a bulk reply.\n * Once this special final command is sent, the code receiving replies starts to\n   match replies with these 20 bytes. When the matching reply is reached it can\n   exit with success.\n\nNaice, what’s next?\nWell, I tried populating Redis locally with a million keys.\n\nIt worked like a charm, in just ~2 seconds. ?\n\nThat’s it!\nI really hope that this post gave you some new insights.\n\nThanks for reading! ?\n\nReferences\n\n 1. Redis Mass Insertion [https://redis.io/topics/mass-insert]\n 2. Redis Protocol [https://redis.io/topics/protocol]\n 3. Port Forwarding in Kubernetes to access applications\n    [https://kubernetes.io/docs/tasks/access-application-cluster/port-forward-access-application-cluster/]\n\nWant our stories to land in your inbox? Sign up for our newsletter!\n[https://mailchi.mp/go-jek/gojek-tech-newsletter]","html":"<h3 id=\"dealing-with-a-lot-of-keys-redis-pipe-mode-is-your-friend-\">Dealing with a lot of keys? Redis’ Pipe Mode is your friend.</h3><p>Hello there!</p><p>In this post, I’ll share my ideas on how we populated Redis (running in a Kubernetes cluster)… in a matter of seconds.</p><p>Here’s what can you expect from this post:</p><p><em><em>1. How to connect to Redis server running in a Kubernetes cluster ?</em></em></p><p><em><em>2. What is Port-forwarding ?</em></em></p><p><em><em>3. How to use Redis mass insertion &amp; push millions of keys in seconds ?</em></em></p><p><em><em>4. How to generate Redis Protocol ?</em></em></p><p><em><em>5. How to read /parse a CSV in Ruby ?</em></em></p><p>Wait, but why do I need to do this? ?</p><p>At Gojek, we use Redis in one of the services for caching drivers for faster lookups. Since we have deployed this service to new clusters, we needed to populate Redis with ~81K keys.</p><h2 id=\"what-we-didn-t-do-and-should-not-be-done-\">What we didn’t do (and should not be done)</h2><p>Well, this. ?</p><p><code>$ redis-cli -h \"hostname\" -p 6379 set \"key\" \"value\"</code></p><p>This simple and easy way of storing a key through <code><a href=\"https://redis.io/topics/rediscli\" rel=\"noopener\">redis-cli</a></code> is okay, but not for thousands or millions of keys. You don’t want to end up waiting for hours unless you are <a href=\"https://en.wikipedia.org/wiki/Phoebe_Buffay#%22Regina_Phalange%22\" rel=\"noopener\">Regina Phalange</a>! ?</p><figure class=\"kg-card kg-embed-card\"><iframe src=\"https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fgiphy.com%2Fembed%2F5xaOcLvROln5TmaaVOM%2Ftwitter%2Fiframe&amp;display_name=Giphy&amp;url=https%3A%2F%2Fgiphy.com%2Fgifs%2Fthecomebackhbo-comeback-the-val-cherish-5xaOcLvROln5TmaaVOM&amp;image=https%3A%2F%2Fmedia.giphy.com%2Fmedia%2F5xaOcLvROln5TmaaVOM%2Fgiphy.gif&amp;key=a19fcc184b9711e1b4764040d3dc5c07&amp;type=text%2Fhtml&amp;schema=giphy\" allowfullscreen=\"\" frameborder=\"0\" height=\"301\" width=\"435\" title=\"Lisa Kudrow Thank You GIF by The Comeback HBO - Find &amp; Share on GIPHY\" class=\"s t u iu ai\" scrolling=\"auto\" style=\"box-sizing: inherit; position: absolute; top: 0px; left: 0px; width: 680px; height: 470.516px;\"></iframe></figure><p>Using a normal Redis client to perform mass insertion is not a good idea. The naive approach of sending one command after the other is slow, because you have to pay for the round trip time for every command.</p><h1 id=\"let-s-do-something-different-\">Let’s do something different!</h1><p>We will use Redis mass insertion, but before going to that, let’s talk a bit about <a href=\"https://redis.io/topics/protocol\" rel=\"noopener\">Redis Protocol</a>.</p><p><em><em>Redis clients communicate with the Redis server using a protocol called <strong><strong>RESP</strong></strong> (REdis Serialization Protocol).</em></em></p><p>With that said, let’s go write some code! I like toying around with <a href=\"https://www.ruby-lang.org/en/\" rel=\"noopener\">Ruby</a>, so this was my language of choice.</p><figure class=\"kg-card kg-embed-card kg-card-hascaption\"><iframe src=\"https://blog.gojekengineering.com/media/59319951b0d29feee60832a68f811a18\" allowfullscreen=\"\" frameborder=\"0\" height=\"364\" width=\"680\" title=\"Ruby Script for Redis Mass Insertion\" class=\"s t u iu ai\" scrolling=\"auto\" style=\"box-sizing: inherit; position: absolute; top: 0px; left: 0px; width: 680px; height: 364px;\"></iframe><figcaption>redis_mass_insert.rb</figcaption></figure><p><code>gen_redis_proto</code> function will generate the protocol required for mass insertion.</p><blockquote>2.6.3 &gt; <strong><strong>puts gen_redis_proto(\"SET\",\"mykey\",\"Hello World!\").inspect</strong></strong></blockquote><p>Running the above command in Ruby console, will give us the following protocol.</p><p><code>\"*3\\r\\n$3\\r\\nSET\\r\\n$5\\r\\nmykey\\r\\n$12\\r\\nHello World!\\r\\n\"</code></p><p>Well, this is how a command is represented and sent to the Redis Server through <a href=\"https://redis.io/topics/protocol\" rel=\"noopener\">Redis Protocol</a>.</p><p><code>*&lt;args&gt;&lt;cr&gt;&lt;lf&gt;<br>$&lt;len&gt;&lt;cr&gt;&lt;lf&gt;<br>&lt;arg0&gt;&lt;cr&gt;&lt;lf&gt;<br>&lt;arg1&gt;&lt;cr&gt;&lt;lf&gt;<br>...<br>&lt;argN&gt;&lt;cr&gt;&lt;lf&gt;</code></p><p><em><em>Where <code>&lt;cr&gt;</code> means \"\\r\" (or ASCII character 13) and <code>&lt;lf&gt;</code> means \"\\n\" (or ASCII character 10).</em></em></p><p>We can now run this script, but here’s a catch. Our Redis server runs in a Kubernetes cluster and we didn’t want to install Ruby and its gems inside a cluster. So now?</p><h1 id=\"enter-port-forwarding-\">Enter port-forwarding! ?</h1><p><strong><strong><code>$ kubectl -n \"namespace\" port-forward \"pod-name\" 7000:6379</code></strong></strong></p><p>Connections made to local port 7000 are forwarded to port 6379 of the pod that is running the Redis server. With this connection in place we can use our local workstation to debug the database that is running in the pod.</p><p><em><em><em>Finally, we run our script to populate Redis ?</em></em></em></p><blockquote><strong><strong>$ ruby redis_mass_insert.rb | redis-cli -p 7000 --pipe</strong></strong></blockquote><blockquote>All data transferred. Waiting for the last reply...<br>Last reply received from server.<br>errors: 0, replies: 81003</blockquote><p>We ran this script and it completed within a fraction of seconds!</p><figure class=\"kg-card kg-embed-card\"><iframe src=\"https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fgiphy.com%2Fembed%2FjRARA4zqym98KmvkUy%2Ftwitter%2Fiframe&amp;display_name=Giphy&amp;url=https%3A%2F%2Fgiphy.com%2Fgifs%2FjRARA4zqym98KmvkUy&amp;image=https%3A%2F%2Fmedia.giphy.com%2Fmedia%2FjRARA4zqym98KmvkUy%2Fgiphy.gif&amp;key=a19fcc184b9711e1b4764040d3dc5c07&amp;type=text%2Fhtml&amp;schema=giphy\" allowfullscreen=\"\" frameborder=\"0\" height=\"246\" width=\"435\" title=\"Bingo GIF - Find &amp; Share on GIPHY\" class=\"s t u iu ai\" scrolling=\"auto\" style=\"box-sizing: inherit; position: absolute; top: 0px; left: 0px; width: 680px; height: 384.547px;\"></iframe></figure><h1 id=\"but-how\">But, how?</h1><p>In 2.6 or later versions of Redis the <code>redis-cli</code> utility supports a new mode called <strong><strong>pipe mode</strong></strong> that was designed in order to perform mass insertion.</p><h2 id=\"under-the-hood-of-pipe-mode\">Under the hood of pipe mode</h2><p>According to the official doc:</p><ul><li><em><em>redis-cli — pipe tries to send data as fast as possible to the server.</em></em></li><li><em><em>At the same time it reads data when available, trying to parse it.</em></em></li><li><em><em>Once there is no more data to read from stdin, it sends a special </em></em><strong><strong><em><em>ECHO</em></em></strong></strong><em><em> command with a random 20 bytes string: we are sure this is the latest command sent, and we are sure we can match the reply checking if we receive the same 20 bytes as a bulk reply.</em></em></li><li><em><em>Once this special final command is sent, the code receiving replies starts to match replies with these 20 bytes. When the matching reply is reached it can exit with success.</em></em></li></ul><h1 id=\"naice-what-s-next\">Naice, what’s next?</h1><p>Well, I tried populating Redis locally with <em><em>a million keys.</em></em></p><p>It worked like a charm, in just ~2 seconds. ?</p><figure class=\"kg-card kg-embed-card\"><iframe src=\"https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fgiphy.com%2Fembed%2Fj6ZQKMy3W3629lDJSX%2Ftwitter%2Fiframe&amp;display_name=Giphy&amp;url=https%3A%2F%2Fgiphy.com%2Fgifs%2Fhbo-avenue-5-avenue5-j6ZQKMy3W3629lDJSX&amp;image=https%3A%2F%2Fmedia.giphy.com%2Fmedia%2Fj6ZQKMy3W3629lDJSX%2Fgiphy.gif&amp;key=a19fcc184b9711e1b4764040d3dc5c07&amp;type=text%2Fhtml&amp;schema=giphy\" allowfullscreen=\"\" frameborder=\"0\" height=\"244\" width=\"435\" title=\"Hugh Laurie Charm GIF by HBO - Find &amp; Share on GIPHY\" class=\"s t u iu ai\" scrolling=\"auto\" style=\"box-sizing: inherit; position: absolute; top: 0px; left: 0px; width: 680px; height: 381.422px;\"></iframe></figure><h1 id=\"that-s-it-\">That’s it!</h1><p>I really hope that this post gave you some new insights.</p><p>Thanks for reading! ?</p><p><strong><strong>References</strong></strong></p><ol><li><a href=\"https://redis.io/topics/mass-insert\" rel=\"noopener\">Redis Mass Insertion</a></li><li><a href=\"https://redis.io/topics/protocol\" rel=\"noopener\">Redis Protocol</a></li><li><a href=\"https://kubernetes.io/docs/tasks/access-application-cluster/port-forward-access-application-cluster/\" rel=\"noopener\">Port Forwarding in Kubernetes to access applications</a></li></ol><figure class=\"kg-card kg-image-card\"><img src=\"https://miro.medium.com/max/60/1*Yigf1nGxRKjzV7vIC_YkYg.png?q=20\" class=\"kg-image\"></figure><p>Want our stories to land in your inbox? <a href=\"https://mailchi.mp/go-jek/gojek-tech-newsletter\" rel=\"noopener\">Sign up for our newsletter!</a></p>","url":"https://gojek-ghost.zysk.in/how-we-pushed-a-million-keys-to-redis-in-seconds/","canonical_url":null,"uuid":"399d0acb-04ee-4db6-8925-35c9dd3533e5","page":null,"codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5eafa30734df85001e15f489","reading_time":3}},"pageContext":{"slug":"how-we-pushed-a-million-keys-to-redis-in-seconds"}}}