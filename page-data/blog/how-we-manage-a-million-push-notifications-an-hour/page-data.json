{"componentChunkName":"component---src-templates-post-js","path":"/blog/how-we-manage-a-million-push-notifications-an-hour/","result":{"data":{"ghostPost":{"id":"Ghost__Post__5ec2af987aa22c4066f83ac4","title":"How We Manage a Million Push Notifications an Hour","slug":"how-we-manage-a-million-push-notifications-an-hour","featured":false,"feature_image":"https://gojek-ghost.zysk.in/content/images/2020/05/1_tEOdkRN79DncrPtPfF8KIA.jpeg","excerpt":"3 million+ orders a day across 20+ products on multiple devices, operating systems, and services. Thatâ€™s a lot of notifications. ðŸ˜…","custom_excerpt":"3 million+ orders a day across 20+ products on multiple devices, operating systems, and services. Thatâ€™s a lot of notifications. ðŸ˜…","visibility":"public","created_at_pretty":"18 May, 2020","published_at_pretty":"29 August, 2019","updated_at_pretty":"18 May, 2020","created_at":"2020-05-18T21:24:00.000+05:30","published_at":"2019-08-29T09:30:00.000+05:30","updated_at":"2020-05-18T21:44:11.000+05:30","meta_title":null,"meta_description":"3 million+ orders a day across 20+ products on multiple devices, operating systems, and services. Thatâ€™s a lot of notifications. ðŸ˜…","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Gojek","slug":"gojek","bio":null,"profile_image":null,"twitter":"@gojektech","facebook":null,"website":"http://www.gojek.io"}],"primary_author":{"name":"Gojek","slug":"gojek","bio":null,"profile_image":null,"twitter":"@gojektech","facebook":null,"website":"http://www.gojek.io"},"primary_tag":{"name":"Tech","slug":"tech","description":"Learnings from technical challenges solved at Gojek, how-tos, and programming tips.","feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Tech","slug":"tech","description":"Learnings from technical challenges solved at Gojek, how-tos, and programming tips.","feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"By Soham Kamani\n\nPush notifications are an essential tool to inform users about events that\nrequire their immediate attention. At Gojek, we handle more than 3 million\norders a day across our 20+ products.\n\nAs you can imagine, the number of push notifications we send are proportionally\nlarge â€” about a million every hour to be exact.This post describes the\nchallenges we faced while working with such high notification volumes, and the\nsolutions we developed to solve them.\n\nVolume is only one part of the problem, many additional challenges were somewhat\nunique to Gojek:\n\n1. Multiple applications\nGojek isnâ€™t comprised of just a single app. In addition to the Gojek app for\ncustomers, we also have GoLife, as well as our driver apps, merchant apps, and\nservice provider apps for GoLife.\n\nWhen one of our systems wants to send a notification, it could be for a specific\napplication of a user (for example, we donâ€™t want to send GoLife booking\nnotifications to the Gojek app), or for all applications (for example, a\npromotional notification).\n\nOur system needed to be flexible enough to choose between an option to broadcast\nthe notification to all applications, or to a specific application.\n\n2. Multiple notification providers\nSince we support both iOS and Android for our customer applications, we needed\nto support multiple notification systems.\n\nFor Android devices, we have FCM (Firebase Cloud Messaging) and the deprecated\nGCM (Google Cloud Messaging) API. For iOS, we have APNS (Apple Push Notification\nservice).\n\nEach notification provider has different API keys and tokens for different\napplication IDs. For example, the FCM API key would be different for GoLife as\nopposed to Gojek.\n\n3. Multiple devices per user\nWe allow our users to stay signed in to multiple devices at a time. For us, this\nalso means that any push notification sent to the user must be sent to all of\nthe devices that the user is currently logged into.\n\nThis is also a combination of the previous two problems:\n\n 1. The user can be logged into multiple applications on a single device (Gojek\n    + GoLife)\n 2. The user may be logged into different devices, where each device requires a\n    different push notification provider. For example, a user can be logged into\n    Gojek on their Android, as well as iOS device.\n\n4. Multiple services that want to send notifications\nGojek uses a micro-service architecture, where the services of each of our\nproducts need to send notifications to our users.\n\nWe want to make it as easy as possible for any service to be able to send a\nnotification, without worrying about the multiple devices and providers that we\ndiscussed.\n\nPush notification service architecture\n\nIn order to address the above challenges, and make sure that the API remains as\nsimple as possible, we built our notification system as three components:\n\n 1. Notification server â€” exposes the API to send notifications, and pushes it\n    as a job on our job queue\n 2. Token store â€” stores the devices and devices tokens of all the currently\n    logged-in users\n 3. Notification worker â€” consumes jobs on the job queue and sends notifications\n    via the notification providers.\n\nEach component abstracts away some part of the problems we discussed above.\nLetâ€™s take a look at each part in more detail:\n\n1. Token store\nOnce a user is logged into our application, the application makes a call to the\ntoken store API with their device token and application ID.\n\n\nThis entry is then removed when the user logs out.\n\n> The token store abstracts the process of deciding which devices to send a\nnotification to for each user\n2. Notification server\nThis is an HTTP server that exposes an API internally to send notifications.\n\nIn order to make things simple, the API accepts the user ID, and an optional\napplication ID as HTTP headers, and notification information in the request\nbody:\n\nPOST http://<base_url>/notification\nuser_id: <user_id>\napplication_id: <application_id>\n\n{\n\"payload\": {},\n\"title\": \"You driver is here\",\n\"message\": \"Please meet your driver at the pickup point\"\n}\n\nThe server fetches all of the users devices from the token store, and schedules\na job for each of the users devices.\n\n> The notification server abstracts the external interface to the system. Now,\nother services in Gojek that need to send out a notification just need to call\nour API with the user ID, and the system takes care of the rest\n3. Job Queue\nWe use RabbitMQ as an exchange for our job queues. We have a queue for each\napplication ID and provider type.\n\n\nThis is important because we want to isolate failures for each application and\nprovider type. For example, if our FCM token expires for com.gojek.app, we don't\nwant to stall the jobs for com.gojek.life or com.gojek.driver.bike.\n\n4. Notification workers\n\nThe worker processes consume messages from the job queues, and send out messages\nto the respective notification providers.\n\nIn order to make our code simpler, and to accommodate different service\nproviders if needed, we make use of interfaces to abstract the functionality\nimplemented by each provider:\n\ntype PushService interface {\nPush(ctx context.Context, m PushRequest) (PushResponse, error)\n}\n\nThe Push method takes a request object and returns a response object.\n\nThe request structure contains information related to the recipient and\nadditional options about the notification, like expiry time, title and text:\n\ntype PushRequest struct {\nDeviceID Â  string \nTitle Â  Â  Â string\nMessage Â  Â string\nPayload Â  Â map[string]interface{}\n//some other parameters omitted\n}\n\nThe response contains information on whether the notification was sent to the\nproviderâ€™s server successfully:\n\ntype PushResponse struct {\nSuccess Â  Â  Â  Â  bool\nErrorMsg Â  Â  Â  Â string\n}\nWe then implement the interface for specific providers. For example, the code\nfor Google FCM provider, and Apples APNS provider looks something like this:\n\ntype FCMProvider struct {\n// configuration for our provider, like API token and URL endpoint\n}func (p *FCMProvider) Push(ctx context.Context, m queue.Message)\n(notification.PushResponse, error) {\n// code to send a notification payload to FCMs server\n}type APNSProvider struct {\n// configuration for our provider, like API token and URL endpoint\n}func (p *APNSProvider) Push(ctx context.Context, m queue.Message)\n(notification.PushResponse, error) {\n// code to send a notification payload to FCMs server\n}\n\n> The notification worker abstracts the process of selecting the correct provider\nto send the notification. It selects the correct provider, with the correct API\nkey based on the application ID of the message received from the queue.\nConclusion\nBy finding common patterns in the challenges we faced, and abstracting them into\ntheir own services, we turned a relatively complex problem into a suite of\nservices that are reasonably straightforward and easy to manage on their own.\n\nEach time we found a point which needed to handle multiple implementations of\nthe same core logic, we put it behind a dedicated service:\n\n 1. Multiple devices for a user was put behind the token service\n 2. Multiple applications were given a common interface on notification server\n 3. Multiple providers were handled by individual job queues and notification\n    workers\n\nIn the end, we wound up with a system that can comfortably handle over a million\nnotifications every hour.\n\n\n--------------------------------------------------------------------------------\n\nWant more updates on how we build scalable systems for Southeast Asiaâ€™s\n#SuperApp? Sign up for our newsletter!\n[https://mailchi.mp/go-jek/gojek-tech-newsletter]","html":"<p>By Soham Kamani</p><p>Push notifications are an essential tool to inform users about events that require their immediate attention. At Gojek, we handle more than 3 million orders a day across our 20+ products.</p><p>As you can imagine, the number of push notifications we send are proportionally large â€” about a million every hour to be exact.This post describes the challenges we faced while working with such high notification volumes, and the solutions we developed to solve them.</p><p>Volume is only one part of the problem, many additional challenges were somewhat unique to Gojek:</p><h1 id=\"1-multiple-applications\">1. Multiple applications</h1><p>Gojek isnâ€™t comprised of just a single app. In addition to the Gojek app for customers, we also have GoLife, as well as our driver apps, merchant apps, and service provider apps for GoLife.</p><figure class=\"kg-card kg-image-card\"><img src=\"https://miro.medium.com/max/882/1*LydaxXs7dKWE8OvGt7Opnw.png\" class=\"kg-image\"></figure><p>When one of our systems wants to send a notification, it could be for a specific application of a user (for example, we donâ€™t want to send GoLife booking notifications to the Gojek app), or for all applications (for example, a promotional notification).</p><p>Our system needed to be flexible enough to choose between an option to broadcast the notification to all applications, or to a specific application.</p><h1 id=\"2-multiple-notification-providers\">2. Multiple notification providers</h1><p>Since we support both iOS and Android for our customer applications, we needed to support multiple notification systems.</p><p>For Android devices, we have FCM (Firebase Cloud Messaging) and the deprecated GCM (Google Cloud Messaging) API. For iOS, we have APNS (Apple Push Notification service).</p><figure class=\"kg-card kg-image-card\"><img src=\"https://miro.medium.com/max/962/1*gx05-ArzDJLasMbmiOmiqA.png\" class=\"kg-image\"></figure><p>Each notification provider has different API keys and tokens for different application IDs. For example, the FCM API key would be different for GoLife as opposed to Gojek.</p><h1 id=\"3-multiple-devices-per-user\">3. Multiple devices per user</h1><p>We allow our users to stay signed in to multiple devices at a time. For us, this also means that any push notification sent to the user must be sent to all of the devices that the user is currently logged into.</p><p>This is also a combination of the previous two problems:</p><ol><li>The user can be logged into multiple applications on a single device (Gojek + GoLife)</li><li>The user may be logged into different devices, where each device requires a different push notification provider. For example, a user can be logged into Gojek on their Android, as well as iOS device.</li></ol><h1 id=\"4-multiple-services-that-want-to-send-notifications\">4. Multiple services that want to send notifications</h1><p>Gojek uses a micro-service architecture, where the services of each of our products need to send notifications to our users.</p><p>We want to make it as easy as possible for any service to be able to send a notification, without worrying about the multiple devices and providers that we discussed.</p><figure class=\"kg-card kg-image-card\"><img src=\"https://miro.medium.com/max/501/1*6IaF4_PwdHWk6RowO0OnoA.png\" class=\"kg-image\"></figure><p>Push notification service architecture</p><p>In order to address the above challenges, and make sure that the API remains as simple as possible, we built our notification system as three components:</p><ol><li><strong><strong>Notification server</strong></strong> â€” exposes the API to send notifications, and pushes it as a job on our job queue</li><li><strong><strong>Token store</strong></strong> â€” stores the devices and devices tokens of all the currently logged-in users</li><li><strong><strong>Notification worker</strong></strong> â€” consumes jobs on the job queue and sends notifications via the notification providers.</li></ol><figure class=\"kg-card kg-image-card kg-width-wide\"><img src=\"https://miro.medium.com/max/1902/1*2Nmx4MeYAXgekpr3uD8dng.png\" class=\"kg-image\"></figure><p>Each component abstracts away some part of the problems we discussed above. Letâ€™s take a look at each part in more detail:</p><h2 id=\"1-token-store\">1. Token store</h2><p>Once a user is logged into our application, the application makes a call to the token store API with their device token and application ID.<br></p><figure class=\"kg-card kg-image-card kg-width-wide\"><img src=\"https://miro.medium.com/max/2014/1*UoYZSCamWMlz5DcK7fJ9zQ.png\" class=\"kg-image\"></figure><p>This entry is then removed when the user logs out.</p><blockquote><em><em>The token store abstracts the process of deciding which devices to send a notification to for each user</em></em></blockquote><h2 id=\"2-notification-server\">2. Notification server</h2><p>This is an HTTP server that exposes an API internally to send notifications.</p><p>In order to make things simple, the API accepts the user ID, and an optional application ID as HTTP headers, and notification information in the request body:</p><p><code>POST http://&lt;base_url&gt;/notification<br>user_id: &lt;user_id&gt;<br>application_id: &lt;application_id&gt;</code></p><p><code>{<br>\t\"payload\": {},<br>\t\"title\": \"You driver is here\",<br>\t\"message\": \"Please meet your driver at the pickup point\"<br>}</code></p><p>The server fetches all of the users devices from the token store, and schedules a job for each of the users devices.</p><blockquote><em><em>The notification server abstracts the external interface to the system. Now, other services in Gojek that need to send out a notification just need to call our API with the user ID, and the system takes care of the rest</em></em></blockquote><h2 id=\"3-job-queue\">3. Job Queue</h2><p>We use RabbitMQ as an exchange for our job queues. We have a queue for each application ID and provider type.<br></p><figure class=\"kg-card kg-image-card kg-width-wide\"><img src=\"https://miro.medium.com/max/1832/1*Mg8xAvNt3o_6W7syBRst-w.png\" class=\"kg-image\"></figure><p>This is important because we want to isolate failures for each application and provider type. For example, if our FCM token expires for <code>com.gojek.app</code>, we don't want to stall the jobs for <code>com.gojek.life</code> or <code>com.gojek.driver.bike</code>.</p><p>4. Notification workers</p><p>The worker processes consume messages from the job queues, and send out messages to the respective notification providers.</p><p>In order to make our code simpler, and to accommodate different service providers if needed, we make use of interfaces to abstract the functionality implemented by each provider:</p><p><code>type PushService interface {<br>\tPush(ctx context.Context, m PushRequest) (PushResponse, error)<br>}</code></p><p>The <code>Push</code> method takes a request object and returns a response object.</p><p>The request structure contains information related to the recipient and additional options about the notification, like expiry time, title and text:</p><p><code>type PushRequest struct {<br>\tDeviceID Â  string <br>\tTitle Â  Â  Â string<br>\tMessage Â  Â string<br>\tPayload Â  Â map[string]interface{}<br><em><em>//some other parameters omitted</em></em><br>}</code></p><p>The response contains information on whether the notification was sent to the providerâ€™s server successfully:</p><p><code>type PushResponse struct {<br>\tSuccess Â  Â  Â  Â  bool<br>\tErrorMsg Â  Â  Â  Â string<br>}</code><br>We then implement the interface for specific providers. For example, the code for Google FCM provider, and Apples APNS provider looks something like this:</p><p><code>type FCMProvider struct {<br>\t<em><em>// configuration for our provider, like API token and URL endpoint</em></em><br>}func (p *FCMProvider) Push(ctx context.Context, m queue.Message) (notification.PushResponse, error) {<br>\t<em><em>// code to send a notification payload to FCMs server</em></em><br>}type APNSProvider struct {<br>\t<em><em>// configuration for our provider, like API token and URL endpoint</em></em><br>}func (p *APNSProvider) Push(ctx context.Context, m queue.Message) (notification.PushResponse, error) {<br>\t<em><em>// code to send a notification payload to FCMs server</em></em><br>}</code></p><blockquote><em><em>The notification worker abstracts the process of selecting the correct provider to send the notification. It selects the correct provider, with the correct API key based on the application ID of the message received from the queue.</em></em></blockquote><h1 id=\"conclusion\">Conclusion</h1><p>By finding common patterns in the challenges we faced, and abstracting them into their own services, we turned a relatively complex problem into a suite of services that are reasonably straightforward and easy to manage on their own.</p><p>Each time we found a point which needed to handle multiple implementations of the same core logic, we put it behind a dedicated service:</p><ol><li>Multiple devices for a user was put behind the token service</li><li>Multiple applications were given a common interface on notification server</li><li>Multiple providers were handled by individual job queues and notification workers</li></ol><p>In the end, we wound up with a system that can comfortably handle <strong><strong>over a million notifications every hour</strong></strong>.</p><hr><p>Want more updates on how we build scalable systems for Southeast Asiaâ€™s #SuperApp? <a href=\"https://mailchi.mp/go-jek/gojek-tech-newsletter\" rel=\"noopener\">Sign up for our newsletter!</a></p>","url":"https://gojek-ghost.zysk.in/how-we-manage-a-million-push-notifications-an-hour/","canonical_url":null,"uuid":"b9ad7304-57c6-4ff7-9a4e-6424cb767b77","page":null,"codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5ec2af987aa22c4066f83ac4","reading_time":5}},"pageContext":{"slug":"how-we-manage-a-million-push-notifications-an-hour"}}}