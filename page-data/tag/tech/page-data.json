{"componentChunkName":"component---src-templates-tag-js","path":"/tag/tech/","result":{"data":{"ghostTag":{"slug":"tech","name":"Tech","visibility":"public","feature_image":null,"description":"Learnings from technical challenges solved at Gojek, how-tos, and programming tips.","meta_title":null,"meta_description":null},"allGhostPost":{"edges":[{"node":{"id":"Ghost__Post__5eafa30734df85001e15f489","title":"How We Pushed a Million Keys to Redis in Seconds","slug":"how-we-pushed-a-million-keys-to-redis-in-seconds","featured":false,"feature_image":"https://res-2.cloudinary.com/hcq4cvthp/image/upload/q_auto/v1/ghost-blog-images/1_gN5KGQcKSipjSlQqEppJMA.jpg","excerpt":"Dealing with a lot of keys? Redis’ Pipe Mode is your friend.\nHello there!\n\nIn this post, I’ll share my ideas on how we populated Redis (running in a\nKubernetes cluster)… in a matter of seconds.\n\nHere’s what can you expect from this post:\n\n1. How to connect to Redis server running in a Kubernetes cluster ?\n\n2. What is Port-forwarding ?\n\n3. How to use Redis mass insertion & push millions of keys in seconds ?\n\n4. How to generate Redis Protocol ?\n\n5. How to read /parse a CSV in Ruby ?\n\nWait, but why","custom_excerpt":null,"visibility":"public","created_at_pretty":"04 May, 2020","published_at_pretty":"04 May, 2020","updated_at_pretty":"12 May, 2020","created_at":"2020-05-04T10:37:19.000+05:30","published_at":"2020-05-04T10:45:13.000+05:30","updated_at":"2020-05-12T11:50:45.000+05:30","meta_title":"How We Pushed a Million Keys to Redis in Seconds","meta_description":"Dealing with a lot of keys? Redis’ Pipe Mode is your friend.","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Gojek","slug":"gojek","bio":null,"profile_image":null,"twitter":"@gojektech","facebook":null,"website":"http://www.gojek.io"}],"primary_author":{"name":"Gojek","slug":"gojek","bio":null,"profile_image":null,"twitter":"@gojektech","facebook":null,"website":"http://www.gojek.io"},"primary_tag":{"name":"Tech","slug":"tech","description":"Learnings from technical challenges solved at Gojek, how-tos, and programming tips.","feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Tech","slug":"tech","description":"Learnings from technical challenges solved at Gojek, how-tos, and programming tips.","feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"Dealing with a lot of keys? Redis’ Pipe Mode is your friend.\nHello there!\n\nIn this post, I’ll share my ideas on how we populated Redis (running in a\nKubernetes cluster)… in a matter of seconds.\n\nHere’s what can you expect from this post:\n\n1. How to connect to Redis server running in a Kubernetes cluster ?\n\n2. What is Port-forwarding ?\n\n3. How to use Redis mass insertion & push millions of keys in seconds ?\n\n4. How to generate Redis Protocol ?\n\n5. How to read /parse a CSV in Ruby ?\n\nWait, but why do I need to do this? ?\n\nAt Gojek, we use Redis in one of the services for caching drivers for faster\nlookups. Since we have deployed this service to new clusters, we needed to\npopulate Redis with ~81K keys.\n\nWhat we didn’t do (and should not be done)\nWell, this. ?\n\n$ redis-cli -h \"hostname\" -p 6379 set \"key\" \"value\"\n\nThis simple and easy way of storing a key through redis-cli\n[https://redis.io/topics/rediscli] is okay, but not for thousands or millions of\nkeys. You don’t want to end up waiting for hours unless you are Regina Phalange\n[https://en.wikipedia.org/wiki/Phoebe_Buffay#%22Regina_Phalange%22]! ?\n\nUsing a normal Redis client to perform mass insertion is not a good idea. The\nnaive approach of sending one command after the other is slow, because you have\nto pay for the round trip time for every command.\n\nLet’s do something different!\nWe will use Redis mass insertion, but before going to that, let’s talk a bit\nabout Redis Protocol [https://redis.io/topics/protocol].\n\nRedis clients communicate with the Redis server using a protocol called RESP \n(REdis Serialization Protocol).\n\nWith that said, let’s go write some code! I like toying around with Ruby\n[https://www.ruby-lang.org/en/], so this was my language of choice.\n\nredis_mass_insert.rbgen_redis_proto function will generate the protocol required for mass insertion.\n\n> 2.6.3 > puts gen_redis_proto(\"SET\",\"mykey\",\"Hello World!\").inspect\nRunning the above command in Ruby console, will give us the following protocol.\n\n\"*3\\r\\n$3\\r\\nSET\\r\\n$5\\r\\nmykey\\r\\n$12\\r\\nHello World!\\r\\n\"\n\nWell, this is how a command is represented and sent to the Redis Server through \nRedis Protocol [https://redis.io/topics/protocol].\n\n*<args><cr><lf>\n$<len><cr><lf>\n<arg0><cr><lf>\n<arg1><cr><lf>\n...\n<argN><cr><lf>\n\nWhere <cr> means \"\\r\" (or ASCII character 13) and <lf> means \"\\n\" (or ASCII\ncharacter 10).\n\nWe can now run this script, but here’s a catch. Our Redis server runs in a\nKubernetes cluster and we didn’t want to install Ruby and its gems inside a\ncluster. So now?\n\nEnter port-forwarding! ?\n$ kubectl -n \"namespace\" port-forward \"pod-name\" 7000:6379\n\nConnections made to local port 7000 are forwarded to port 6379 of the pod that\nis running the Redis server. With this connection in place we can use our local\nworkstation to debug the database that is running in the pod.\n\nFinally, we run our script to populate Redis ?\n\n> $ ruby redis_mass_insert.rb | redis-cli -p 7000 --pipe\n> All data transferred. Waiting for the last reply...\nLast reply received from server.\nerrors: 0, replies: 81003\nWe ran this script and it completed within a fraction of seconds!\n\nBut, how?\nIn 2.6 or later versions of Redis the redis-cli utility supports a new mode\ncalled pipe mode that was designed in order to perform mass insertion.\n\nUnder the hood of pipe mode\nAccording to the official doc:\n\n * redis-cli — pipe tries to send data as fast as possible to the server.\n * At the same time it reads data when available, trying to parse it.\n * Once there is no more data to read from stdin, it sends a special ECHO \n   command with a random 20 bytes string: we are sure this is the latest command\n   sent, and we are sure we can match the reply checking if we receive the same\n   20 bytes as a bulk reply.\n * Once this special final command is sent, the code receiving replies starts to\n   match replies with these 20 bytes. When the matching reply is reached it can\n   exit with success.\n\nNaice, what’s next?\nWell, I tried populating Redis locally with a million keys.\n\nIt worked like a charm, in just ~2 seconds. ?\n\nThat’s it!\nI really hope that this post gave you some new insights.\n\nThanks for reading! ?\n\nReferences\n\n 1. Redis Mass Insertion [https://redis.io/topics/mass-insert]\n 2. Redis Protocol [https://redis.io/topics/protocol]\n 3. Port Forwarding in Kubernetes to access applications\n    [https://kubernetes.io/docs/tasks/access-application-cluster/port-forward-access-application-cluster/]\n\nWant our stories to land in your inbox? Sign up for our newsletter!\n[https://mailchi.mp/go-jek/gojek-tech-newsletter]","html":"<h3 id=\"dealing-with-a-lot-of-keys-redis-pipe-mode-is-your-friend-\">Dealing with a lot of keys? Redis’ Pipe Mode is your friend.</h3><p>Hello there!</p><p>In this post, I’ll share my ideas on how we populated Redis (running in a Kubernetes cluster)… in a matter of seconds.</p><p>Here’s what can you expect from this post:</p><p><em><em>1. How to connect to Redis server running in a Kubernetes cluster ?</em></em></p><p><em><em>2. What is Port-forwarding ?</em></em></p><p><em><em>3. How to use Redis mass insertion &amp; push millions of keys in seconds ?</em></em></p><p><em><em>4. How to generate Redis Protocol ?</em></em></p><p><em><em>5. How to read /parse a CSV in Ruby ?</em></em></p><p>Wait, but why do I need to do this? ?</p><p>At Gojek, we use Redis in one of the services for caching drivers for faster lookups. Since we have deployed this service to new clusters, we needed to populate Redis with ~81K keys.</p><h2 id=\"what-we-didn-t-do-and-should-not-be-done-\">What we didn’t do (and should not be done)</h2><p>Well, this. ?</p><p><code>$ redis-cli -h \"hostname\" -p 6379 set \"key\" \"value\"</code></p><p>This simple and easy way of storing a key through <code><a href=\"https://redis.io/topics/rediscli\" rel=\"noopener\">redis-cli</a></code> is okay, but not for thousands or millions of keys. You don’t want to end up waiting for hours unless you are <a href=\"https://en.wikipedia.org/wiki/Phoebe_Buffay#%22Regina_Phalange%22\" rel=\"noopener\">Regina Phalange</a>! ?</p><figure class=\"kg-card kg-embed-card\"><iframe src=\"https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fgiphy.com%2Fembed%2F5xaOcLvROln5TmaaVOM%2Ftwitter%2Fiframe&amp;display_name=Giphy&amp;url=https%3A%2F%2Fgiphy.com%2Fgifs%2Fthecomebackhbo-comeback-the-val-cherish-5xaOcLvROln5TmaaVOM&amp;image=https%3A%2F%2Fmedia.giphy.com%2Fmedia%2F5xaOcLvROln5TmaaVOM%2Fgiphy.gif&amp;key=a19fcc184b9711e1b4764040d3dc5c07&amp;type=text%2Fhtml&amp;schema=giphy\" allowfullscreen=\"\" frameborder=\"0\" height=\"301\" width=\"435\" title=\"Lisa Kudrow Thank You GIF by The Comeback HBO - Find &amp; Share on GIPHY\" class=\"s t u iu ai\" scrolling=\"auto\" style=\"box-sizing: inherit; position: absolute; top: 0px; left: 0px; width: 680px; height: 470.516px;\"></iframe></figure><p>Using a normal Redis client to perform mass insertion is not a good idea. The naive approach of sending one command after the other is slow, because you have to pay for the round trip time for every command.</p><h1 id=\"let-s-do-something-different-\">Let’s do something different!</h1><p>We will use Redis mass insertion, but before going to that, let’s talk a bit about <a href=\"https://redis.io/topics/protocol\" rel=\"noopener\">Redis Protocol</a>.</p><p><em><em>Redis clients communicate with the Redis server using a protocol called <strong><strong>RESP</strong></strong> (REdis Serialization Protocol).</em></em></p><p>With that said, let’s go write some code! I like toying around with <a href=\"https://www.ruby-lang.org/en/\" rel=\"noopener\">Ruby</a>, so this was my language of choice.</p><figure class=\"kg-card kg-embed-card kg-card-hascaption\"><iframe src=\"https://blog.gojekengineering.com/media/59319951b0d29feee60832a68f811a18\" allowfullscreen=\"\" frameborder=\"0\" height=\"364\" width=\"680\" title=\"Ruby Script for Redis Mass Insertion\" class=\"s t u iu ai\" scrolling=\"auto\" style=\"box-sizing: inherit; position: absolute; top: 0px; left: 0px; width: 680px; height: 364px;\"></iframe><figcaption>redis_mass_insert.rb</figcaption></figure><p><code>gen_redis_proto</code> function will generate the protocol required for mass insertion.</p><blockquote>2.6.3 &gt; <strong><strong>puts gen_redis_proto(\"SET\",\"mykey\",\"Hello World!\").inspect</strong></strong></blockquote><p>Running the above command in Ruby console, will give us the following protocol.</p><p><code>\"*3\\r\\n$3\\r\\nSET\\r\\n$5\\r\\nmykey\\r\\n$12\\r\\nHello World!\\r\\n\"</code></p><p>Well, this is how a command is represented and sent to the Redis Server through <a href=\"https://redis.io/topics/protocol\" rel=\"noopener\">Redis Protocol</a>.</p><p><code>*&lt;args&gt;&lt;cr&gt;&lt;lf&gt;<br>$&lt;len&gt;&lt;cr&gt;&lt;lf&gt;<br>&lt;arg0&gt;&lt;cr&gt;&lt;lf&gt;<br>&lt;arg1&gt;&lt;cr&gt;&lt;lf&gt;<br>...<br>&lt;argN&gt;&lt;cr&gt;&lt;lf&gt;</code></p><p><em><em>Where <code>&lt;cr&gt;</code> means \"\\r\" (or ASCII character 13) and <code>&lt;lf&gt;</code> means \"\\n\" (or ASCII character 10).</em></em></p><p>We can now run this script, but here’s a catch. Our Redis server runs in a Kubernetes cluster and we didn’t want to install Ruby and its gems inside a cluster. So now?</p><h1 id=\"enter-port-forwarding-\">Enter port-forwarding! ?</h1><p><strong><strong><code>$ kubectl -n \"namespace\" port-forward \"pod-name\" 7000:6379</code></strong></strong></p><p>Connections made to local port 7000 are forwarded to port 6379 of the pod that is running the Redis server. With this connection in place we can use our local workstation to debug the database that is running in the pod.</p><p><em><em><em>Finally, we run our script to populate Redis ?</em></em></em></p><blockquote><strong><strong>$ ruby redis_mass_insert.rb | redis-cli -p 7000 --pipe</strong></strong></blockquote><blockquote>All data transferred. Waiting for the last reply...<br>Last reply received from server.<br>errors: 0, replies: 81003</blockquote><p>We ran this script and it completed within a fraction of seconds!</p><figure class=\"kg-card kg-embed-card\"><iframe src=\"https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fgiphy.com%2Fembed%2FjRARA4zqym98KmvkUy%2Ftwitter%2Fiframe&amp;display_name=Giphy&amp;url=https%3A%2F%2Fgiphy.com%2Fgifs%2FjRARA4zqym98KmvkUy&amp;image=https%3A%2F%2Fmedia.giphy.com%2Fmedia%2FjRARA4zqym98KmvkUy%2Fgiphy.gif&amp;key=a19fcc184b9711e1b4764040d3dc5c07&amp;type=text%2Fhtml&amp;schema=giphy\" allowfullscreen=\"\" frameborder=\"0\" height=\"246\" width=\"435\" title=\"Bingo GIF - Find &amp; Share on GIPHY\" class=\"s t u iu ai\" scrolling=\"auto\" style=\"box-sizing: inherit; position: absolute; top: 0px; left: 0px; width: 680px; height: 384.547px;\"></iframe></figure><h1 id=\"but-how\">But, how?</h1><p>In 2.6 or later versions of Redis the <code>redis-cli</code> utility supports a new mode called <strong><strong>pipe mode</strong></strong> that was designed in order to perform mass insertion.</p><h2 id=\"under-the-hood-of-pipe-mode\">Under the hood of pipe mode</h2><p>According to the official doc:</p><ul><li><em><em>redis-cli — pipe tries to send data as fast as possible to the server.</em></em></li><li><em><em>At the same time it reads data when available, trying to parse it.</em></em></li><li><em><em>Once there is no more data to read from stdin, it sends a special </em></em><strong><strong><em><em>ECHO</em></em></strong></strong><em><em> command with a random 20 bytes string: we are sure this is the latest command sent, and we are sure we can match the reply checking if we receive the same 20 bytes as a bulk reply.</em></em></li><li><em><em>Once this special final command is sent, the code receiving replies starts to match replies with these 20 bytes. When the matching reply is reached it can exit with success.</em></em></li></ul><h1 id=\"naice-what-s-next\">Naice, what’s next?</h1><p>Well, I tried populating Redis locally with <em><em>a million keys.</em></em></p><p>It worked like a charm, in just ~2 seconds. ?</p><figure class=\"kg-card kg-embed-card\"><iframe src=\"https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fgiphy.com%2Fembed%2Fj6ZQKMy3W3629lDJSX%2Ftwitter%2Fiframe&amp;display_name=Giphy&amp;url=https%3A%2F%2Fgiphy.com%2Fgifs%2Fhbo-avenue-5-avenue5-j6ZQKMy3W3629lDJSX&amp;image=https%3A%2F%2Fmedia.giphy.com%2Fmedia%2Fj6ZQKMy3W3629lDJSX%2Fgiphy.gif&amp;key=a19fcc184b9711e1b4764040d3dc5c07&amp;type=text%2Fhtml&amp;schema=giphy\" allowfullscreen=\"\" frameborder=\"0\" height=\"244\" width=\"435\" title=\"Hugh Laurie Charm GIF by HBO - Find &amp; Share on GIPHY\" class=\"s t u iu ai\" scrolling=\"auto\" style=\"box-sizing: inherit; position: absolute; top: 0px; left: 0px; width: 680px; height: 381.422px;\"></iframe></figure><h1 id=\"that-s-it-\">That’s it!</h1><p>I really hope that this post gave you some new insights.</p><p>Thanks for reading! ?</p><p><strong><strong>References</strong></strong></p><ol><li><a href=\"https://redis.io/topics/mass-insert\" rel=\"noopener\">Redis Mass Insertion</a></li><li><a href=\"https://redis.io/topics/protocol\" rel=\"noopener\">Redis Protocol</a></li><li><a href=\"https://kubernetes.io/docs/tasks/access-application-cluster/port-forward-access-application-cluster/\" rel=\"noopener\">Port Forwarding in Kubernetes to access applications</a></li></ol><figure class=\"kg-card kg-image-card\"><img src=\"https://miro.medium.com/max/60/1*Yigf1nGxRKjzV7vIC_YkYg.png?q=20\" class=\"kg-image\"></figure><p>Want our stories to land in your inbox? <a href=\"https://mailchi.mp/go-jek/gojek-tech-newsletter\" rel=\"noopener\">Sign up for our newsletter!</a></p>","url":"https://gojek-ghost.zysk.in/how-we-pushed-a-million-keys-to-redis-in-seconds/","canonical_url":null,"uuid":"399d0acb-04ee-4db6-8925-35c9dd3533e5","page":null,"codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5eafa30734df85001e15f489","reading_time":3}},{"node":{"id":"Ghost__Post__5eaf9f2234df85001e15f42d","title":"OK Google, Meet Gojek","slug":"ok-google-meet-gojekwe-added-gojeks-ride-hailing-and-food-ordering-functions-to-google-assistant-heres-what-we-learned-in-the-process","featured":true,"feature_image":"https://res-5.cloudinary.com/hcq4cvthp/image/upload/q_auto/v1/ghost-blog-images/1_QaQg1VnVWuhAebytXO-gKg.jpg","excerpt":"We added Gojek’s ride-hailing and food ordering functions to Google Assistant. Here’s what we learned in the process.","custom_excerpt":"We added Gojek’s ride-hailing and food ordering functions to Google Assistant. Here’s what we learned in the process.","visibility":"public","created_at_pretty":"04 May, 2020","published_at_pretty":"04 May, 2020","updated_at_pretty":"12 May, 2020","created_at":"2020-05-04T10:20:42.000+05:30","published_at":"2020-05-04T10:33:07.000+05:30","updated_at":"2020-05-12T11:46:27.000+05:30","meta_title":"Ok Google, Meet Gojek","meta_description":"We added Gojek’s ride-hailing and food ordering functions to Google Assistant. Here’s what we learned in the process.","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Gojek","slug":"gojek","bio":null,"profile_image":null,"twitter":"@gojektech","facebook":null,"website":"http://www.gojek.io"}],"primary_author":{"name":"Gojek","slug":"gojek","bio":null,"profile_image":null,"twitter":"@gojektech","facebook":null,"website":"http://www.gojek.io"},"primary_tag":{"name":"Tech","slug":"tech","description":"Learnings from technical challenges solved at Gojek, how-tos, and programming tips.","feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Tech","slug":"tech","description":"Learnings from technical challenges solved at Gojek, how-tos, and programming tips.","feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"We added Gojek’s ride-hailing and food ordering functions to Google Assistant.\nHere’s what we learned in the process.\nBy Vikas Bajpayee and Lokesh Kalal\n\nOur aim behind building a Super App was to help our users get rid of the daily\nfrictions in their lives. But the journey doesn’t stop there. Even after\nbuilding all these convenient products, we still try and reduce frictions that\nmay be encountered even within our app — such as booking a ride or ordering\nfood.\n\nSo we thought, why don’t we integrate with Google Assistant, and let our users\ncommunicate with our products in a new way?\n\nIn this post, we explain how we integrated our food and transport products with\nthe Google Assistant.\n\nThe why\nWe’ve already addressed one part of the why — convenience. The other is user\nre-engagement. According to this survey\n[https://andrewchen.co/new-data-shows-why-losing-80-of-your-mobile-users-is-normal-and-that-the-best-apps-do-much-better/?utm_content=buffere4fa2&utm_medium=twitter.com&utm_source=social&utm_campaign=buffer] \nconducted by Silicon Valley researcher Andrew Chen 77% of users stop using an\napp three days after they install it. Within a month, that number goes up to\n90%. ?\n\nThe how\nTo help integrate Android apps with the Google Assistant, Google launched App\nActions:\n\nWhat are app actions?\nApp Actions are a new way to make your android app content available in places\nlike Google Search, Google Assistant etc. From a user’s perspective, App Actions\nbehave like shortcuts to parts of your Android app. When users invoke an App\nAction, the Assistant either launches a screen in the Android app that the user\nhas already installed or shows an embedded visual card (Android Slice) that\nusers can interact with.\n\nApp actions provide a faster way for users to access Android apps. It can be\nachieved in two ways:- either user can be directed to a specific\nactivity(screen) using a deep link or user may see relevant content on the\nAssistant itself called Slices.\n\nMore info on this can be found here: \nhttps://developers.google.com/assistant/app/overview\n\nWhat are Slices?\nSlices are super-powered app actions. They provide a way to interact with apps\nwithout moving away from Assistant by showing a small piece of UI within\nAssistant. Slices are UI templates that can display rich, dynamic, and\ninteractive content from the app in Google Assistant.\n\nSlices can help users perform tasks faster by enabling engagement outside of the\nfullscreen app experience.\n\nYou can build Slices as enhancements to App Actions.\n\nHere’s an example:\n\nWe choose to use slices to show food order status, as the order status will have\nlimited information (eg. Driver is on the way to Restaurant, with his location\non Map ) which can be easily shown in a small piece of UI segment.\n\nIn fact, this functionality was recently demoed on stage at a Google event in\nIndonesia. You can check it out below:\n\nApp Actions Demo at #Google4ID 2019How does it work?\nWhenever a user says or types something in Assistant, assistant parses the\nquery. If the query matches the built-in intent\n[https://developers.google.com/assistant/app/reference/built-in-intents] grammar\nthen Google Assistant extracts the query parameter in schema.org\n[https://schema.org/] and generates a deep link URL using the mapping we provide\nin an actions.xml file.\n\nGoogle then attaches those extracted parameters to the deep link URL and creates\na final deep link which allows a user to launch specific content or screens in\nthe app.\n\nLet’s dig a little deeper:\n\nGoogle applies Machine Learning and Artificial Intelligence (Natural Language\nProcessing) to understand all the sentences we type in Assistant.\n\nWhile users can type anything they want in Assistant and the system gets better\nat interpreting them over time, but there are some sentences for specific intent\nthat are fixed by Google. More info here\n[https://developers.google.com/assistant/app/reference/built-in-intents#create-taxi-reservation]\n.\n\nHow did we integrate our services with Assistant?\nThe core of integrating Gojek with Assistant involved creating actions on Google\nAssistant with actions.xml file.\n\nLet’s explore how to do this:\n\n1. Create actions.xml file in your XML folder. This contains all the actions\nwith built-in intents which define what actions our app can support in the\nAssistant. Each action contains built-in intents\n[https://developers.google.com/assistant/app/reference/built-in-intents#create-taxi-reservation] \nsupported by Google as a <intent-name> tag.\n\n2. Define a fulfilment mode for each app action — which can be deep links or\nslices. You have to pass a fulfilment mode in each action. This is compulsory.\n\n3. Pass the URL template which will allow a user to launch your app — this can\nbe the deep link to your app or URL to Slice provider.\n\n4. Define entity-set — the Gojek app is available in multiple locales, so to\nprovide locale for all the regions, we added the entity-set, which allows\nAssistant to understand more than one version of category. ex:- taxi can be\npronounced as taksi in Bahasa.\n\nSo, If you want locale for your specific parameter in deep-link URL, you can\nsimply attach an entity-set with that parameter, see how you can achieve this in\nbelow example\n\n<parameter name=”taxiReservation.category”><entity-set-reference\nentitySetId=”TransportCategoryEntitySet” /></parameter>\n\n5. Add a reference to actions.xml file using the <meta> tag in your app’s\nmanifest.xml file inside the application tag.\n\nIn order to integrate Slices:\n\n 1. Implement an Android Slice by following the steps described in the Slices\n    Getting Started guide\n    [https://developer.android.com/guide/slices/getting-started].\n 2. In the actions.xml file, in the <fulfillment> element, specify \n    fulfillmentMode=“actions.fulfillment.SLICE” to indicate that a user intent\n    can be fulfilled using a Slice in your app.\n\nA few quick notes on what we learnt\n 1. Testing this feature is pretty hard and things become weird when you have\n    multiple build types of your app. For testing, you need a build type on the\n    Play Store, (which means the package name of the testing build should match\n    the package name of the published app). You can use a plugin (developed by\n    Google) called App Actions Test Tool\n    [https://developers.google.com/assistant/app/test-tool] for testing this\n    feature.\n\n> Please make sure you are following points while testing with App Actions Test\nTool:\na) Log in to Android Studio and Google Assistant with the account which has\naccess to your published app on Play console.\nb) ApplicationId of the app should be the same as your published app.\nc) Your Gradle should be built successfully.\nd) Use App Action Tool to create and update preview and test the app actions and\nslice.\n2. If your app is used in different locales, you can create locales using \nentity-set\n[https://developers.google.com/assistant/app/action-schema#entity-set-reference] \nin the actions.xml file.\n\n3. In order to give early builds to QA or other users (if you have multiple\nbuild types in your app), you can create an internal test track on Play console\nand add relevant people to it. This allows you to share the build to production\nfor only some listed users.\n\n(See this\n[https://support.google.com/googleplay/android-developer/answer/3131213?hl=en] \nfor how you can create an internal test track for your app.)\n\n4. Actions.xml shouldn’t be obfuscated in release apk — it means if you are\nusing any obfuscated tools like proguard then actions.xml shouldn’t be\nobfuscated there.\n\n5. Slices can be requested before the onCreate of your application is completed.\nYou can run into issues if you are using something which is initialised in \nonCreate while creating slices.\n\n6. Don't refresh slices from onBindSlice() method, it will end up in an infinite\nloop where Google Assistant will call onBindSlice() infinitely.\n\nThat’s all from us folks. Hope this post gave you a better understanding of how\nApp Actions and Slices work with Google Assistant. Working on this feature was\nan amazing experience for us. If you use the Gojek app, make sure to give them a\ntry and let us know what you think. ?\n\n\n--------------------------------------------------------------------------------\n\nLiked what you read? Sign up for our newsletter\n[https://mailchi.mp/go-jek/gojek-tech-newsletter] and we’ll send you updates\nfrom the blog straight to your inbox! ?","html":"<h3 id=\"we-added-gojek-s-ride-hailing-and-food-ordering-functions-to-google-assistant-here-s-what-we-learned-in-the-process-\">We added Gojek’s ride-hailing and food ordering functions to Google Assistant. Here’s what we learned in the process.</h3><p><strong><strong><em>By Vikas Bajpayee and Lokesh Kalal</em></strong></strong></p><p>Our aim behind building a Super App was to help our users get rid of the daily frictions in their lives. But the journey doesn’t stop there. Even after building all these convenient products, we still try and reduce frictions that may be encountered even within our app — such as booking a ride or ordering food.</p><p>So we thought, why don’t we integrate with Google Assistant, and let our users communicate with our products in a new way?</p><p>In this post, we explain how we integrated our food and transport products with the Google Assistant.</p><h1 id=\"the-why\">The why</h1><p>We’ve already addressed one part of the <em><em>why — </em></em>convenience. The other is user re-engagement. According to <a href=\"https://andrewchen.co/new-data-shows-why-losing-80-of-your-mobile-users-is-normal-and-that-the-best-apps-do-much-better/?utm_content=buffere4fa2&amp;utm_medium=twitter.com&amp;utm_source=social&amp;utm_campaign=buffer\" rel=\"noopener\">this survey</a> conducted by Silicon Valley researcher Andrew Chen 77% of users stop using an app three days after they install it. Within a month, that number goes up to 90%. ?</p><h1 id=\"the-how\">The how</h1><p>To help integrate Android apps with the Google Assistant, Google launched App Actions:</p><h2 id=\"what-are-app-actions\">What are app actions?</h2><p>App Actions are a new way to make your android app content available in places like Google Search, Google Assistant etc. From a user’s perspective, App Actions behave like shortcuts to parts of your Android app. When users invoke an App Action, the Assistant either launches a screen in the Android app that the user has already installed or shows an embedded visual card (Android Slice) that users can interact with.</p><figure class=\"kg-card kg-image-card\"><img src=\"https://miro.medium.com/max/260/1*w4jk-CTME9amkb5dsIQDzw.gif\" class=\"kg-image\"></figure><p>App actions provide a faster way for users to access Android apps. It can be achieved in two ways:- either user can be directed to a specific activity(screen) using a deep link or user may see relevant content on the Assistant itself called Slices.</p><figure class=\"kg-card kg-image-card\"><img src=\"https://miro.medium.com/max/260/1*KPBLtVMjiHBOPEJ53E9F8A.gif\" class=\"kg-image\"></figure><p>More info on this can be found here: <a href=\"https://developers.google.com/assistant/app/overview\" rel=\"noopener\">https://developers.google.com/assistant/app/overview</a></p><h2 id=\"what-are-slices\"><strong>What are Slices?</strong></h2><p>Slices are super-powered app actions. They provide a way to interact with apps without moving away from Assistant by showing a small piece of UI within Assistant. Slices are UI templates that can display rich, dynamic, and interactive content from the app in Google Assistant.</p><p><em><em>Slices can help users perform tasks faster by enabling engagement outside of the fullscreen app experience.</em></em></p><p>You can build Slices as enhancements to App Actions.</p><p>Here’s an example:</p><figure class=\"kg-card kg-image-card\"><img src=\"https://miro.medium.com/max/1080/1*EFF30b3185UtwKYjx0VP1A.jpeg\" class=\"kg-image\"></figure><p>We choose to use slices to show food order status, as the order status will have limited information (eg. Driver is on the way to Restaurant, with his location on Map ) which can be easily shown in a small piece of UI segment.</p><p>In fact, this functionality was recently demoed on stage at a Google event in Indonesia. You can check it out below:</p><figure class=\"kg-card kg-embed-card kg-card-hascaption\"><iframe src=\"https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fwww.youtube.com%2Fembed%2F0u20Iu4m2Co%3Fstart%3D5805%26feature%3Doembed%26start%3D5805&amp;url=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3D0u20Iu4m2Co&amp;image=https%3A%2F%2Fi.ytimg.com%2Fvi%2F0u20Iu4m2Co%2Fhqdefault.jpg&amp;key=a19fcc184b9711e1b4764040d3dc5c07&amp;type=text%2Fhtml&amp;schema=youtube\" allowfullscreen=\"\" frameborder=\"0\" height=\"480\" width=\"854\" title=\"#Google4ID 2019\" class=\"s t u iu ai\" scrolling=\"auto\" style=\"box-sizing: inherit; position: absolute; top: 0px; left: 0px; width: 680px; height: 382.188px;\"></iframe><figcaption>App Actions Demo at #Google4ID 2019</figcaption></figure><h1 id=\"how-does-it-work\"><strong>How does it work?</strong></h1><p>Whenever a user says or types something in Assistant, assistant parses the query. If the query matches the<a href=\"https://developers.google.com/assistant/app/reference/built-in-intents\" rel=\"noopener\"> built-in intent</a> grammar then Google Assistant extracts the query parameter in<a href=\"https://schema.org/\" rel=\"noopener\"> schema.org</a> and generates a deep link URL using the mapping we provide in an actions.xml file.</p><p>Google then attaches those extracted parameters to the deep link URL and creates a final deep link which allows a user to launch specific content or screens in the app.</p><figure class=\"kg-card kg-image-card\"><img src=\"https://miro.medium.com/max/1490/0*jUlpzwbXbFIgGy7s\" class=\"kg-image\"></figure><p>Let’s dig a little deeper:</p><p>Google applies Machine Learning and Artificial Intelligence (Natural Language Processing) to understand all the sentences we type in Assistant.</p><p>While users can type anything they want in Assistant and the system gets better at interpreting them over time, but there are some sentences for specific intent that are fixed by Google. More info <a href=\"https://developers.google.com/assistant/app/reference/built-in-intents#create-taxi-reservation\" rel=\"noopener\">here</a>.</p><h1 id=\"how-did-we-integrate-our-services-with-assistant\"><strong>How did we integrate our services with Assistant?</strong></h1><p>The core of integrating Gojek with Assistant involved creating actions on Google Assistant with actions.xml file.</p><p>Let’s explore how to do this:</p><p>1. Create <strong><strong>actions.xml</strong></strong> file in your XML folder. This contains all the actions with built-in intents which define what actions our app can support in the Assistant. Each action contains<a href=\"https://developers.google.com/assistant/app/reference/built-in-intents#create-taxi-reservation\" rel=\"noopener\"> built-in intents</a> supported by Google as a &lt;intent-name&gt; tag.</p><p>2. Define a fulfilment mode for each app action — which can be deep links or slices. You have to pass a fulfilment mode in each action. This is compulsory.</p><p>3. Pass the URL template which will allow a user to launch your app — this can be the deep link to your app or URL to Slice provider.</p><p>4. Define entity-set — the Gojek app is available in multiple locales, so to provide locale for all the regions, we added the entity-set, which allows Assistant to understand more than one version of category. ex:- taxi can be pronounced as taksi in Bahasa.</p><p>So, If you want locale for your specific parameter in deep-link URL, you can simply attach an entity-set with that parameter, see how you can achieve this in below example</p><p><em>&lt;parameter name=”taxiReservation.category”&gt;&lt;entity-set-reference entitySetId=”TransportCategoryEntitySet” /&gt;&lt;/parameter&gt;</em></p><p>5. Add a reference to <strong><strong>actions.xml</strong></strong> file using the &lt;meta&gt; tag in your app’s manifest.xml file inside the application tag.</p><p><strong><strong>In order to integrate Slices:</strong></strong></p><ol><li>Implement an Android Slice by following the steps described in the <a href=\"https://developer.android.com/guide/slices/getting-started\" rel=\"noopener\">Slices Getting Started guide</a>.</li><li>In the actions.xml file, in the <code>&lt;fulfillment&gt;</code> element, specify <code>fulfillmentMode=“actions.fulfillment.SLICE”</code> to indicate that a user intent can be fulfilled using a Slice in your app.</li></ol><h1 id=\"a-few-quick-notes-on-what-we-learnt\"><strong>A few quick notes on what we learnt</strong></h1><ol><li>Testing this feature is pretty hard and things become weird when you have multiple build types of your app. For testing, you need a build type on the Play Store, (which means the package name of the testing build should match the package name of the published app). You can use a plugin (developed by Google) called<a href=\"https://developers.google.com/assistant/app/test-tool\" rel=\"noopener\"> <strong><strong>App Actions Test Tool</strong></strong></a> for testing this feature.</li></ol><blockquote><em><em>Please make sure you are following points while testing with App Actions Test Tool:</em></em><br><em><em>a) Log in to Android Studio and Google Assistant with the account which has access to your published app on Play console.</em></em><br><em><em>b) <code>ApplicationId</code> of the app should be the same as your published app.</em></em><br><em><em>c) Your Gradle should be built successfully.</em></em><br><em><em>d) Use App Action Tool to create and update preview and test the app actions and slice.</em></em></blockquote><p>2. If your app is used in different locales, you can create locales using <a href=\"https://developers.google.com/assistant/app/action-schema#entity-set-reference\" rel=\"noopener\">entity-set</a> in the actions.xml file.</p><p>3. In order to give early builds to QA or other users (if you have multiple build types in your app), you can create an internal test track on Play console and add relevant people to it. This allows you to share the build to production for only some listed users.</p><p>(See <a href=\"https://support.google.com/googleplay/android-developer/answer/3131213?hl=en\" rel=\"noopener\">this</a> for how you can create an internal test track for your app.)</p><p>4. Actions.xml shouldn’t be <strong><strong>obfuscated</strong></strong> in release apk — it means if you are using any obfuscated tools like proguard then actions.xml shouldn’t be obfuscated there.</p><p>5. Slices can be requested before the <code>onCreate</code> of your application is completed. You can run into issues if you are using something which is initialised in <code>onCreate</code> while creating slices.</p><p>6. Don't refresh slices from <code>onBindSlice()</code> method, it will end up in an infinite loop where Google Assistant will call <code>onBindSlice()</code> infinitely.</p><p>That’s all from us folks. Hope this post gave you a better understanding of how App Actions and Slices work with Google Assistant. Working on this feature was an amazing experience for us. If you use the Gojek app, make sure to give them a try and let us know what you think. ?</p><hr><p>Liked what you read? <a href=\"https://mailchi.mp/go-jek/gojek-tech-newsletter\" rel=\"noopener\">Sign up for our newsletter</a> and we’ll send you updates from the blog straight to your inbox! ?</p>","url":"https://gojek-ghost.zysk.in/ok-google-meet-gojekwe-added-gojeks-ride-hailing-and-food-ordering-functions-to-google-assistant-heres-what-we-learned-in-the-process/","canonical_url":null,"uuid":"a980d332-756f-4f47-a97f-921a11196ed7","page":null,"codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5eaf9f2234df85001e15f42d","reading_time":6}},{"node":{"id":"Ghost__Post__5eb12eb3f7c7da001effce0b","title":"How We Supercharged Chat","slug":"how-we-supercharged-chat","featured":false,"feature_image":"https://res-3.cloudinary.com/hcq4cvthp/image/upload/q_auto/v1/ghost-blog-images/1_tuDgHHPUouXxzsK4OEzPaw.jpg","excerpt":"The nuts and bolts of the framework that allows other Gojek products to leverage our chat platform via extensions.","custom_excerpt":"The nuts and bolts of the framework that allows other Gojek products to leverage our chat platform via extensions.","visibility":"public","created_at_pretty":"05 May, 2020","published_at_pretty":"10 January, 2020","updated_at_pretty":"18 May, 2020","created_at":"2020-05-05T14:45:31.000+05:30","published_at":"2020-01-10T09:30:00.000+05:30","updated_at":"2020-05-18T20:45:50.000+05:30","meta_title":null,"meta_description":"The nuts and bolts of the framework that allows other Gojek products to leverage our chat platform via extensions.","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Gojek","slug":"gojek","bio":null,"profile_image":null,"twitter":"@gojektech","facebook":null,"website":"http://www.gojek.io"}],"primary_author":{"name":"Gojek","slug":"gojek","bio":null,"profile_image":null,"twitter":"@gojektech","facebook":null,"website":"http://www.gojek.io"},"primary_tag":{"name":"Tech","slug":"tech","description":"Learnings from technical challenges solved at Gojek, how-tos, and programming tips.","feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Tech","slug":"tech","description":"Learnings from technical challenges solved at Gojek, how-tos, and programming tips.","feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"By Benzi Ahamed\n\nThe Gojek consumer app comes with a chat feature. This allows users to have\nconversations with:\n\n * The currently assigned driver partner in relation to a booking.\n * Other Gojek users, provided they are known contacts in your address book.\n   These can be either personal or group chats.\n\nIn order to use the chat platform as springboard to other services within\nGojek’s vast ecosystem, we wanted to expose some features that integrate with\nour other offerings — within the convenience of a chat window.\n\nOne of the first service options we wanted to focus on was payments — paying and\nrequesting for money between individuals and groups. Chat had the platform to\ncreate connections between people, GoPay had payments — it was time to marry the\ntwo.\n\nArchitecture\nTo start with, as a chat platform team, we did not really know anything about\nthe payments domain. In fact, most of the integrations we planned for required\ncollaborating with other product teams within Gojek.\n\nWe decided early on that we needed a plugin-based framework that other product\nteams (and even chat team’s core services) could use. We also decided that the\nAPI surface area for this new framework should have as much as possible in\ncommon between the Android and iOS implementations.\n\nThe first use case we focused on was integrating payment options within chat —\nwhich would help us kickstart our design and feature rollout.\n\nApproach\nIn the vein of keeping things as simple as possible, we came up with the\nfollowing set of guidelines:\n\n * The chat subsystem can expose add-on features to the user\n * These features will not be part of the core chat offering, but can be\n   plugged-in externally\n * These plugin-based entities — chat extensions — can have mainly two\n   capabilities\n * Display a button (widget) in a chat window to trigger the chat extension’s\n   functionality\n * Display chat extension messages that can support rich text, images,\n   call-to-actions\n\nChat extension messages are merely text messages with additional metadata. While\nplain text-based messages are rendered by the core chat rendering system, chat\nextension messages need to be rendered by the chat extension that created the\nmessage.\n\nChat Extension Framework — Key ActorsThe illustration above depicts the final\nframework components we came up with.\n\n * Chat Extension Providers are responsible for vending Chat Extensions based on\n   the active Chat Session (there might be cases where we want to enable a\n   certain feature only for certain types of chats e.g. those between our\n   drivers and customers).\n * Chat Extensions are the components responsible for vending trigger points (\n   Widget Views) and custom message views (Extension Message Views).\n\nWhile the core subsystem takes care of managing life cycles of the chat\nextensions, widgets, and message views, it is the responsibility of extension\nauthors to purely focus on the implementation details of their feature.\n\nWith the above design in place, we were ready to start collaborating and start\nimplementing features.\n\nLet’s take a look at some integrations we were able to build collaboratively.\n\nSample Integrations\nPayments\nThe first integration we did was Request and Pay flows. Utilising GoPay,\ncustomers can make payments and request for money from friends.\n\nHere’s the Request Flow in action, within a personal chat:\n\nRequest Money from an IndividualIn a group chat, Request Flow translates to a\nSplit Bill flow:\n\nRequest Money in a GroupHere’s the Pay flow in action:\n\nPay via GoPay, continue conversation in ChatIn the Pay Flow, we start with\nmaking a payment from the home-screen of the Gojek App. Once a payment is done,\nyou have an option to continue to chat with the person you made the payment to.\nThis flow is of course in addition to similar flows for Request where you can\ntrigger a payment within chat itself.\n\nThe payments team were able to create a UX flow that could be triggered either\nfrom the home screen or the chat window.\n\nRestaurant Sharing\nNext up, our GoFood team wanted to explore sharing restaurant information via\nchat. Since we already had support for extensions at this point in time, we\ncreated a generic Share Via Chat flow that supports sharing simple text messages\nor custom extension message content.\n\nIn the Pay Flow, we start with making a payment from the home-screen of the\nGojek App. Once a payment is done, you have an option to continue to chat with\nthe person you made the payment to. This flow is of course in addition to\nsimilar flows for Request where you can trigger a payment within chat itself.\n\nThe payments team were able to create a UX flow that could be triggered either\nfrom the home screen or the chat window.\n\nRestaurant Sharing\nNext up, our GoFood team wanted to explore sharing restaurant information via\nchat. Since we already had support for extensions at this point in time, we\ncreated a generic Share Via Chat flow that supports sharing simple text messages\nor custom extension message content.\n\n\nShare Restaurant Details via ChatWhat’s interesting is that once a Restaurant\nCard has been shared via chat, a recipient clicking on that card can proceed to\nmake a food order, directly from the chat window itself. This is made possible\nby the fact that Extension Message Views can be fully interactive (e.g. detect\nuser taps), and the chat window provides contextual navigation controls to them.\n\nImage Sharing\nLastly, let us take a look at the most recent feature we rolled out to\nproduction — image sharing in our customer-driver chats.\n\nImage Sharing via ChatDuring the implementation of this feature, we recognised\nthat image sharing would be better triggered from the chat window if there was a\ndirect shortcut button (e.g. a camera icon) within the bottom text input area of\nthe chat window.\n\nThis leads us to enhance our extension framework to allow Chat Extensions to\nprovide Chat Extension Shortcuts as well. Our updated framework looks like\nbelow:\n\nLessons Learned\nIt has been a great journey so far exploring various kinds of integrations in a\nsimple chat window. We have a lot more planned, but in the meanwhile, here are a\nfew key things we learned along the way\n\n * When you are developing a platform, evangelising what your platform provides\n   is key. This is equally relevant if you are a platform-product company, or a\n   platform team within a company. We conducted an internal chat extension\n   hackathon which helped broaden our outreach, and saw some pretty cool ideas\n   implemented including Live Location Sharing, Booking Sharing, Games, Sticker\n   Packs etc.\n * Document your public API! Teams are more willing to collaborate if you have\n   proper, up-to-date documentation in place. We created detailed technical\n   documents, integration guides, and even provided a sample chat extension (a\n   starter-pack, if you will) — these greatly helped teams adopting these new\n   features. Also, the feedback we got during the internal hackathon fed\n   directly back into improving our documentation.\n * Having a common design language helped our Android and iOS engineers to\n   collaborate more closely. It was easier for the team to work on implementing\n   the feature by focussing on the common characteristics during tech\n   discussion, design ratification sessions etc. and leaving the nuances of each\n   platform to respective teams during development. Having a common language\n   that engineers can speak (irrespective of their specialisations) improves\n   cross-communications and collaboration.\n * It is important to design solutions exercising self-imposed constraints.\n   These constraints should directly limit the engineering scope of the\n   solution. As engineers, we are all too comfortable going down the technical\n   analysis rabbit-hole in our pursuit of coming up with a well rounded, albeit\n   (possibly) over-engineered solution. This usually ends up in complicated\n   designs, which translate into complicated code. It is better to design\n   simpler systems and iteratively add smaller features, where each iteration\n   cycle should also incorporate refactoring every step of the way. Even though\n   we knew having something like Extension Shortcuts was nice to have from the\n   get go, we had to exercise restraint and only implemented the feature when it\n   was actually required.\n * We cannot stress this enough, but continuous refactoring (whenever required)\n   is one surefire way to reduce the build-up of tech debt in any codebase.\n   Improve a function here, rename a variable there, refactor a class into two —\n   every little bit helps. It is the responsibility of the entire team to be\n   engaged in this exercise.\n\nSo there you have it, a quick look at the way the core chat team developed a\nbase extension framework that is currently being used to build richer\nintegrations into chat.\n\n\n--------------------------------------------------------------------------------\n\nWant more where that come from? Have our updates delivered straight to your\ninbox by signing up for our newsletter!\n[https://mailchi.mp/go-jek/gojek-tech-newsletter]","html":"<p>By Benzi Ahamed</p><p>The Gojek consumer app comes with a chat feature. This allows users to have conversations with:</p><ul><li>The currently assigned driver partner in relation to a booking.</li><li>Other Gojek users, provided they are known contacts in your address book. These can be either personal or group chats.</li></ul><p>In order to use the chat platform as springboard to other services within Gojek’s vast ecosystem, we wanted to expose some features that integrate with our other offerings — within the convenience of a chat window.</p><p>One of the first service options we wanted to focus on was payments — paying and requesting for money between individuals and groups. Chat had the platform to create connections between people, GoPay had payments — it was time to marry the two.</p><h1 id=\"architecture\">Architecture</h1><p>To start with, as a chat platform team, we did not really know anything about the payments domain. In fact, most of the integrations we planned for required collaborating with other product teams within Gojek.</p><p>We decided early on that we needed a plugin-based framework that other product teams (and even chat team’s core services) could use. We also decided that the API surface area for this new framework should have as much as possible in common between the Android and iOS implementations.</p><p>The first use case we focused on was integrating payment options within chat — which would help us kickstart our design and feature rollout.</p><h2 id=\"approach\">Approach</h2><p>In the vein of keeping things as simple as possible, we came up with the following set of guidelines:</p><ul><li>The chat subsystem can expose add-on features to the user</li><li>These features will not be part of the core chat offering, but can be plugged-in externally</li><li>These plugin-based entities — chat extensions — can have mainly two capabilities</li><li>Display a button (widget) in a chat window to trigger the chat extension’s functionality</li><li>Display chat extension messages that can support rich text, images, call-to-actions</li></ul><p>Chat extension messages are merely text messages with additional metadata. While plain text-based messages are rendered by the core chat rendering system, chat extension messages need to be rendered by the chat extension that created the message.</p><figure class=\"kg-card kg-image-card kg-width-wide kg-card-hascaption\"><img src=\"https://miro.medium.com/max/1980/1*yZbylgYQ7Q7jaF8cooEpeQ.png\" class=\"kg-image\"><figcaption>Chat Extension Framework — Key Actors</figcaption></figure><p>The illustration above depicts the final framework components we came up with.</p><ul><li><strong><strong>Chat Extension Providers</strong></strong> are responsible for vending <strong><strong>Chat Extension</strong></strong>s based on the active <strong><strong>Chat Session</strong></strong> (there might be cases where we want to enable a certain feature only for certain types of chats e.g. those between our drivers and customers).</li><li><strong><strong>Chat Extensions</strong></strong> are the components responsible for vending trigger points (<strong><strong>Widget Views</strong></strong>) and custom message views (<strong><strong>Extension Message Views</strong></strong>).</li></ul><p>While the core subsystem takes care of managing life cycles of the chat extensions, widgets, and message views, it is the responsibility of extension authors to purely focus on the implementation details of their feature.</p><p>With the above design in place, we were ready to start collaborating and start implementing features.</p><p>Let’s take a look at some integrations we were able to build collaboratively.</p><h1 id=\"sample-integrations\">Sample Integrations</h1><h2 id=\"payments\">Payments</h2><p>The first integration we did was Request and Pay flows. Utilising GoPay, customers can make payments and request for money from friends.</p><p>Here’s the Request Flow in action, within a personal chat:</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://miro.medium.com/max/404/1*2mJZ8btzdO7bVq5rXtwvoQ.gif\" class=\"kg-image\"><figcaption>Request Money from an Individual</figcaption></figure><p>In a group chat, Request Flow translates to a Split Bill flow:</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://miro.medium.com/max/402/1*OHgw8oUSuN6n1d8sjWCw7A.gif\" class=\"kg-image\"><figcaption>Request Money in a Group</figcaption></figure><p>Here’s the Pay flow in action:</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://miro.medium.com/max/404/1*6z12Pjg1Vgy8Y-0P1jFPSw.gif\" class=\"kg-image\"><figcaption>Pay via GoPay, continue conversation in Chat</figcaption></figure><p>In the Pay Flow, we start with making a payment from the home-screen of the Gojek App. Once a payment is done, you have an option to continue to chat with the person you made the payment to. This flow is of course in addition to similar flows for Request where you can trigger a payment within chat itself.</p><p>The payments team were able to create a UX flow that could be triggered either from the home screen or the chat window.</p><h2 id=\"restaurant-sharing\">Restaurant Sharing</h2><p>Next up, our GoFood team wanted to explore sharing restaurant information via chat. Since we already had support for extensions at this point in time, we created a generic Share Via Chat flow that supports sharing simple text messages or custom extension message content.</p><p>In the Pay Flow, we start with making a payment from the home-screen of the Gojek App. Once a payment is done, you have an option to continue to chat with the person you made the payment to. This flow is of course in addition to similar flows for Request where you can trigger a payment within chat itself.</p><p>The payments team were able to create a UX flow that could be triggered either from the home screen or the chat window.</p><h2 id=\"restaurant-sharing-1\">Restaurant Sharing</h2><p>Next up, our GoFood team wanted to explore sharing restaurant information via chat. Since we already had support for extensions at this point in time, we created a generic Share Via Chat flow that supports sharing simple text messages or custom extension message content.<br></p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://miro.medium.com/max/404/1*iMz_DNDwFwiCM4aiMRilAg.gif\" class=\"kg-image\"><figcaption>Share Restaurant Details via Chat</figcaption></figure><p>What’s interesting is that once a Restaurant Card has been shared via chat, a recipient clicking on that card can proceed to make a food order, directly from the chat window itself. This is made possible by the fact that Extension Message Views can be fully interactive (e.g. detect user taps), and the chat window provides contextual navigation controls to them.</p><h2 id=\"image-sharing\">Image Sharing</h2><p>Lastly, let us take a look at the most recent feature we rolled out to production — image sharing in our customer-driver chats.</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://miro.medium.com/max/600/1*uFGU-NAQrIM2L4USdNLuWA.gif\" class=\"kg-image\"><figcaption>Image Sharing via Chat</figcaption></figure><p>During the implementation of this feature, we recognised that image sharing would be better triggered from the chat window if there was a direct shortcut button (e.g. a camera icon) within the bottom text input area of the chat window.</p><p>This leads us to enhance our extension framework to allow Chat Extensions to provide Chat Extension Shortcuts as well. Our updated framework looks like below:</p><figure class=\"kg-card kg-image-card kg-width-wide\"><img src=\"https://miro.medium.com/max/2140/1*BDMz2IPpUJcX3M80qI_7bw.png\" class=\"kg-image\"></figure><h1 id=\"lessons-learned\">Lessons Learned</h1><p>It has been a great journey so far exploring various kinds of integrations in a simple chat window. We have a lot more planned, but in the meanwhile, here are a few key things we learned along the way</p><ul><li>When you are developing a platform, evangelising what your platform provides is key. This is equally relevant if you are a platform-product company, or a platform team within a company. We conducted an internal chat extension hackathon which helped broaden our outreach, and saw some pretty cool ideas implemented including Live Location Sharing, Booking Sharing, Games, Sticker Packs etc.</li><li>Document your public API! Teams are more willing to collaborate if you have proper, up-to-date documentation in place. We created detailed technical documents, integration guides, and even provided a sample chat extension (a starter-pack, if you will) — these greatly helped teams adopting these new features. Also, the feedback we got during the internal hackathon fed directly back into improving our documentation.</li><li>Having a common design language helped our Android and iOS engineers to collaborate more closely. It was easier for the team to work on implementing the feature by focussing on the common characteristics during tech discussion, design ratification sessions etc. and leaving the nuances of each platform to respective teams during development. Having a common language that engineers can speak (irrespective of their specialisations) improves cross-communications and collaboration.</li><li>It is important to design solutions exercising self-imposed constraints. These constraints should directly limit the engineering scope of the solution. As engineers, we are all too comfortable going down the technical analysis rabbit-hole in our pursuit of coming up with a well rounded, albeit (possibly) over-engineered solution. This usually ends up in complicated designs, which translate into complicated code. It is better to design simpler systems and iteratively add smaller features, where each iteration cycle should also incorporate refactoring every step of the way. Even though we knew having something like Extension Shortcuts was nice to have from the get go, we had to exercise restraint and only implemented the feature when it was actually required.</li><li>We cannot stress this enough, but <em><em>continuous refactoring</em></em> (whenever required) is one surefire way to reduce the build-up of tech debt in any codebase. Improve a function here, rename a variable there, refactor a class into two — every little bit helps. It is the responsibility of the entire team to be engaged in this exercise.</li></ul><p>So there you have it, a quick look at the way the core chat team developed a base extension framework that is currently being used to build richer integrations into chat.</p><hr><p>Want more where that come from? Have our updates delivered straight to your inbox by <a href=\"https://mailchi.mp/go-jek/gojek-tech-newsletter\">signing up for our newsletter!</a></p>","url":"https://gojek-ghost.zysk.in/how-we-supercharged-chat/","canonical_url":null,"uuid":"a5657369-e813-44f1-af8d-aa2e306bfafd","page":null,"codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5eb12eb3f7c7da001effce0b","reading_time":6}},{"node":{"id":"Ghost__Post__5ec2af987aa22c4066f83ac4","title":"How We Manage a Million Push Notifications an Hour","slug":"how-we-manage-a-million-push-notifications-an-hour","featured":false,"feature_image":"https://gojek-ghost.zysk.in/content/images/2020/05/1_tEOdkRN79DncrPtPfF8KIA.jpeg","excerpt":"3 million+ orders a day across 20+ products on multiple devices, operating systems, and services. That’s a lot of notifications. 😅","custom_excerpt":"3 million+ orders a day across 20+ products on multiple devices, operating systems, and services. That’s a lot of notifications. 😅","visibility":"public","created_at_pretty":"18 May, 2020","published_at_pretty":"29 August, 2019","updated_at_pretty":"18 May, 2020","created_at":"2020-05-18T21:24:00.000+05:30","published_at":"2019-08-29T09:30:00.000+05:30","updated_at":"2020-05-18T21:44:11.000+05:30","meta_title":null,"meta_description":"3 million+ orders a day across 20+ products on multiple devices, operating systems, and services. That’s a lot of notifications. 😅","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Gojek","slug":"gojek","bio":null,"profile_image":null,"twitter":"@gojektech","facebook":null,"website":"http://www.gojek.io"}],"primary_author":{"name":"Gojek","slug":"gojek","bio":null,"profile_image":null,"twitter":"@gojektech","facebook":null,"website":"http://www.gojek.io"},"primary_tag":{"name":"Tech","slug":"tech","description":"Learnings from technical challenges solved at Gojek, how-tos, and programming tips.","feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Tech","slug":"tech","description":"Learnings from technical challenges solved at Gojek, how-tos, and programming tips.","feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"By Soham Kamani\n\nPush notifications are an essential tool to inform users about events that\nrequire their immediate attention. At Gojek, we handle more than 3 million\norders a day across our 20+ products.\n\nAs you can imagine, the number of push notifications we send are proportionally\nlarge — about a million every hour to be exact.This post describes the\nchallenges we faced while working with such high notification volumes, and the\nsolutions we developed to solve them.\n\nVolume is only one part of the problem, many additional challenges were somewhat\nunique to Gojek:\n\n1. Multiple applications\nGojek isn’t comprised of just a single app. In addition to the Gojek app for\ncustomers, we also have GoLife, as well as our driver apps, merchant apps, and\nservice provider apps for GoLife.\n\nWhen one of our systems wants to send a notification, it could be for a specific\napplication of a user (for example, we don’t want to send GoLife booking\nnotifications to the Gojek app), or for all applications (for example, a\npromotional notification).\n\nOur system needed to be flexible enough to choose between an option to broadcast\nthe notification to all applications, or to a specific application.\n\n2. Multiple notification providers\nSince we support both iOS and Android for our customer applications, we needed\nto support multiple notification systems.\n\nFor Android devices, we have FCM (Firebase Cloud Messaging) and the deprecated\nGCM (Google Cloud Messaging) API. For iOS, we have APNS (Apple Push Notification\nservice).\n\nEach notification provider has different API keys and tokens for different\napplication IDs. For example, the FCM API key would be different for GoLife as\nopposed to Gojek.\n\n3. Multiple devices per user\nWe allow our users to stay signed in to multiple devices at a time. For us, this\nalso means that any push notification sent to the user must be sent to all of\nthe devices that the user is currently logged into.\n\nThis is also a combination of the previous two problems:\n\n 1. The user can be logged into multiple applications on a single device (Gojek\n    + GoLife)\n 2. The user may be logged into different devices, where each device requires a\n    different push notification provider. For example, a user can be logged into\n    Gojek on their Android, as well as iOS device.\n\n4. Multiple services that want to send notifications\nGojek uses a micro-service architecture, where the services of each of our\nproducts need to send notifications to our users.\n\nWe want to make it as easy as possible for any service to be able to send a\nnotification, without worrying about the multiple devices and providers that we\ndiscussed.\n\nPush notification service architecture\n\nIn order to address the above challenges, and make sure that the API remains as\nsimple as possible, we built our notification system as three components:\n\n 1. Notification server — exposes the API to send notifications, and pushes it\n    as a job on our job queue\n 2. Token store — stores the devices and devices tokens of all the currently\n    logged-in users\n 3. Notification worker — consumes jobs on the job queue and sends notifications\n    via the notification providers.\n\nEach component abstracts away some part of the problems we discussed above.\nLet’s take a look at each part in more detail:\n\n1. Token store\nOnce a user is logged into our application, the application makes a call to the\ntoken store API with their device token and application ID.\n\n\nThis entry is then removed when the user logs out.\n\n> The token store abstracts the process of deciding which devices to send a\nnotification to for each user\n2. Notification server\nThis is an HTTP server that exposes an API internally to send notifications.\n\nIn order to make things simple, the API accepts the user ID, and an optional\napplication ID as HTTP headers, and notification information in the request\nbody:\n\nPOST http://<base_url>/notification\nuser_id: <user_id>\napplication_id: <application_id>\n\n{\n\"payload\": {},\n\"title\": \"You driver is here\",\n\"message\": \"Please meet your driver at the pickup point\"\n}\n\nThe server fetches all of the users devices from the token store, and schedules\na job for each of the users devices.\n\n> The notification server abstracts the external interface to the system. Now,\nother services in Gojek that need to send out a notification just need to call\nour API with the user ID, and the system takes care of the rest\n3. Job Queue\nWe use RabbitMQ as an exchange for our job queues. We have a queue for each\napplication ID and provider type.\n\n\nThis is important because we want to isolate failures for each application and\nprovider type. For example, if our FCM token expires for com.gojek.app, we don't\nwant to stall the jobs for com.gojek.life or com.gojek.driver.bike.\n\n4. Notification workers\n\nThe worker processes consume messages from the job queues, and send out messages\nto the respective notification providers.\n\nIn order to make our code simpler, and to accommodate different service\nproviders if needed, we make use of interfaces to abstract the functionality\nimplemented by each provider:\n\ntype PushService interface {\nPush(ctx context.Context, m PushRequest) (PushResponse, error)\n}\n\nThe Push method takes a request object and returns a response object.\n\nThe request structure contains information related to the recipient and\nadditional options about the notification, like expiry time, title and text:\n\ntype PushRequest struct {\nDeviceID   string \nTitle      string\nMessage    string\nPayload    map[string]interface{}\n//some other parameters omitted\n}\n\nThe response contains information on whether the notification was sent to the\nprovider’s server successfully:\n\ntype PushResponse struct {\nSuccess         bool\nErrorMsg        string\n}\nWe then implement the interface for specific providers. For example, the code\nfor Google FCM provider, and Apples APNS provider looks something like this:\n\ntype FCMProvider struct {\n// configuration for our provider, like API token and URL endpoint\n}func (p *FCMProvider) Push(ctx context.Context, m queue.Message)\n(notification.PushResponse, error) {\n// code to send a notification payload to FCMs server\n}type APNSProvider struct {\n// configuration for our provider, like API token and URL endpoint\n}func (p *APNSProvider) Push(ctx context.Context, m queue.Message)\n(notification.PushResponse, error) {\n// code to send a notification payload to FCMs server\n}\n\n> The notification worker abstracts the process of selecting the correct provider\nto send the notification. It selects the correct provider, with the correct API\nkey based on the application ID of the message received from the queue.\nConclusion\nBy finding common patterns in the challenges we faced, and abstracting them into\ntheir own services, we turned a relatively complex problem into a suite of\nservices that are reasonably straightforward and easy to manage on their own.\n\nEach time we found a point which needed to handle multiple implementations of\nthe same core logic, we put it behind a dedicated service:\n\n 1. Multiple devices for a user was put behind the token service\n 2. Multiple applications were given a common interface on notification server\n 3. Multiple providers were handled by individual job queues and notification\n    workers\n\nIn the end, we wound up with a system that can comfortably handle over a million\nnotifications every hour.\n\n\n--------------------------------------------------------------------------------\n\nWant more updates on how we build scalable systems for Southeast Asia’s\n#SuperApp? Sign up for our newsletter!\n[https://mailchi.mp/go-jek/gojek-tech-newsletter]","html":"<p>By Soham Kamani</p><p>Push notifications are an essential tool to inform users about events that require their immediate attention. At Gojek, we handle more than 3 million orders a day across our 20+ products.</p><p>As you can imagine, the number of push notifications we send are proportionally large — about a million every hour to be exact.This post describes the challenges we faced while working with such high notification volumes, and the solutions we developed to solve them.</p><p>Volume is only one part of the problem, many additional challenges were somewhat unique to Gojek:</p><h1 id=\"1-multiple-applications\">1. Multiple applications</h1><p>Gojek isn’t comprised of just a single app. In addition to the Gojek app for customers, we also have GoLife, as well as our driver apps, merchant apps, and service provider apps for GoLife.</p><figure class=\"kg-card kg-image-card\"><img src=\"https://miro.medium.com/max/882/1*LydaxXs7dKWE8OvGt7Opnw.png\" class=\"kg-image\"></figure><p>When one of our systems wants to send a notification, it could be for a specific application of a user (for example, we don’t want to send GoLife booking notifications to the Gojek app), or for all applications (for example, a promotional notification).</p><p>Our system needed to be flexible enough to choose between an option to broadcast the notification to all applications, or to a specific application.</p><h1 id=\"2-multiple-notification-providers\">2. Multiple notification providers</h1><p>Since we support both iOS and Android for our customer applications, we needed to support multiple notification systems.</p><p>For Android devices, we have FCM (Firebase Cloud Messaging) and the deprecated GCM (Google Cloud Messaging) API. For iOS, we have APNS (Apple Push Notification service).</p><figure class=\"kg-card kg-image-card\"><img src=\"https://miro.medium.com/max/962/1*gx05-ArzDJLasMbmiOmiqA.png\" class=\"kg-image\"></figure><p>Each notification provider has different API keys and tokens for different application IDs. For example, the FCM API key would be different for GoLife as opposed to Gojek.</p><h1 id=\"3-multiple-devices-per-user\">3. Multiple devices per user</h1><p>We allow our users to stay signed in to multiple devices at a time. For us, this also means that any push notification sent to the user must be sent to all of the devices that the user is currently logged into.</p><p>This is also a combination of the previous two problems:</p><ol><li>The user can be logged into multiple applications on a single device (Gojek + GoLife)</li><li>The user may be logged into different devices, where each device requires a different push notification provider. For example, a user can be logged into Gojek on their Android, as well as iOS device.</li></ol><h1 id=\"4-multiple-services-that-want-to-send-notifications\">4. Multiple services that want to send notifications</h1><p>Gojek uses a micro-service architecture, where the services of each of our products need to send notifications to our users.</p><p>We want to make it as easy as possible for any service to be able to send a notification, without worrying about the multiple devices and providers that we discussed.</p><figure class=\"kg-card kg-image-card\"><img src=\"https://miro.medium.com/max/501/1*6IaF4_PwdHWk6RowO0OnoA.png\" class=\"kg-image\"></figure><p>Push notification service architecture</p><p>In order to address the above challenges, and make sure that the API remains as simple as possible, we built our notification system as three components:</p><ol><li><strong><strong>Notification server</strong></strong> — exposes the API to send notifications, and pushes it as a job on our job queue</li><li><strong><strong>Token store</strong></strong> — stores the devices and devices tokens of all the currently logged-in users</li><li><strong><strong>Notification worker</strong></strong> — consumes jobs on the job queue and sends notifications via the notification providers.</li></ol><figure class=\"kg-card kg-image-card kg-width-wide\"><img src=\"https://miro.medium.com/max/1902/1*2Nmx4MeYAXgekpr3uD8dng.png\" class=\"kg-image\"></figure><p>Each component abstracts away some part of the problems we discussed above. Let’s take a look at each part in more detail:</p><h2 id=\"1-token-store\">1. Token store</h2><p>Once a user is logged into our application, the application makes a call to the token store API with their device token and application ID.<br></p><figure class=\"kg-card kg-image-card kg-width-wide\"><img src=\"https://miro.medium.com/max/2014/1*UoYZSCamWMlz5DcK7fJ9zQ.png\" class=\"kg-image\"></figure><p>This entry is then removed when the user logs out.</p><blockquote><em><em>The token store abstracts the process of deciding which devices to send a notification to for each user</em></em></blockquote><h2 id=\"2-notification-server\">2. Notification server</h2><p>This is an HTTP server that exposes an API internally to send notifications.</p><p>In order to make things simple, the API accepts the user ID, and an optional application ID as HTTP headers, and notification information in the request body:</p><p><code>POST http://&lt;base_url&gt;/notification<br>user_id: &lt;user_id&gt;<br>application_id: &lt;application_id&gt;</code></p><p><code>{<br>\t\"payload\": {},<br>\t\"title\": \"You driver is here\",<br>\t\"message\": \"Please meet your driver at the pickup point\"<br>}</code></p><p>The server fetches all of the users devices from the token store, and schedules a job for each of the users devices.</p><blockquote><em><em>The notification server abstracts the external interface to the system. Now, other services in Gojek that need to send out a notification just need to call our API with the user ID, and the system takes care of the rest</em></em></blockquote><h2 id=\"3-job-queue\">3. Job Queue</h2><p>We use RabbitMQ as an exchange for our job queues. We have a queue for each application ID and provider type.<br></p><figure class=\"kg-card kg-image-card kg-width-wide\"><img src=\"https://miro.medium.com/max/1832/1*Mg8xAvNt3o_6W7syBRst-w.png\" class=\"kg-image\"></figure><p>This is important because we want to isolate failures for each application and provider type. For example, if our FCM token expires for <code>com.gojek.app</code>, we don't want to stall the jobs for <code>com.gojek.life</code> or <code>com.gojek.driver.bike</code>.</p><p>4. Notification workers</p><p>The worker processes consume messages from the job queues, and send out messages to the respective notification providers.</p><p>In order to make our code simpler, and to accommodate different service providers if needed, we make use of interfaces to abstract the functionality implemented by each provider:</p><p><code>type PushService interface {<br>\tPush(ctx context.Context, m PushRequest) (PushResponse, error)<br>}</code></p><p>The <code>Push</code> method takes a request object and returns a response object.</p><p>The request structure contains information related to the recipient and additional options about the notification, like expiry time, title and text:</p><p><code>type PushRequest struct {<br>\tDeviceID   string <br>\tTitle      string<br>\tMessage    string<br>\tPayload    map[string]interface{}<br><em><em>//some other parameters omitted</em></em><br>}</code></p><p>The response contains information on whether the notification was sent to the provider’s server successfully:</p><p><code>type PushResponse struct {<br>\tSuccess         bool<br>\tErrorMsg        string<br>}</code><br>We then implement the interface for specific providers. For example, the code for Google FCM provider, and Apples APNS provider looks something like this:</p><p><code>type FCMProvider struct {<br>\t<em><em>// configuration for our provider, like API token and URL endpoint</em></em><br>}func (p *FCMProvider) Push(ctx context.Context, m queue.Message) (notification.PushResponse, error) {<br>\t<em><em>// code to send a notification payload to FCMs server</em></em><br>}type APNSProvider struct {<br>\t<em><em>// configuration for our provider, like API token and URL endpoint</em></em><br>}func (p *APNSProvider) Push(ctx context.Context, m queue.Message) (notification.PushResponse, error) {<br>\t<em><em>// code to send a notification payload to FCMs server</em></em><br>}</code></p><blockquote><em><em>The notification worker abstracts the process of selecting the correct provider to send the notification. It selects the correct provider, with the correct API key based on the application ID of the message received from the queue.</em></em></blockquote><h1 id=\"conclusion\">Conclusion</h1><p>By finding common patterns in the challenges we faced, and abstracting them into their own services, we turned a relatively complex problem into a suite of services that are reasonably straightforward and easy to manage on their own.</p><p>Each time we found a point which needed to handle multiple implementations of the same core logic, we put it behind a dedicated service:</p><ol><li>Multiple devices for a user was put behind the token service</li><li>Multiple applications were given a common interface on notification server</li><li>Multiple providers were handled by individual job queues and notification workers</li></ol><p>In the end, we wound up with a system that can comfortably handle <strong><strong>over a million notifications every hour</strong></strong>.</p><hr><p>Want more updates on how we build scalable systems for Southeast Asia’s #SuperApp? <a href=\"https://mailchi.mp/go-jek/gojek-tech-newsletter\" rel=\"noopener\">Sign up for our newsletter!</a></p>","url":"https://gojek-ghost.zysk.in/how-we-manage-a-million-push-notifications-an-hour/","canonical_url":null,"uuid":"b9ad7304-57c6-4ff7-9a4e-6424cb767b77","page":null,"codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5ec2af987aa22c4066f83ac4","reading_time":5}},{"node":{"id":"Ghost__Post__5ec2af8a7aa22c4066f83abe","title":"Applying the Single Responsibility Principle to Microservices","slug":"applying-the-single-responsibility-principle-to-microservices","featured":false,"feature_image":"https://gojek-ghost.zysk.in/content/images/2020/05/1_5lEpe0Ab9138LC9cY1QZSQ.jpeg","excerpt":"The single responsibility principle helped us fix Icebreaker, our chat service. This is how we did it.","custom_excerpt":"The single responsibility principle helped us fix Icebreaker, our chat service. This is how we did it.","visibility":"public","created_at_pretty":"18 May, 2020","published_at_pretty":"05 February, 2019","updated_at_pretty":"18 May, 2020","created_at":"2020-05-18T21:23:46.000+05:30","published_at":"2019-02-05T09:30:00.000+05:30","updated_at":"2020-05-18T21:30:57.000+05:30","meta_title":null,"meta_description":"The single responsibility principle helped us fix Icebreaker, our chat service. This is how we did it.","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Gojek","slug":"gojek","bio":null,"profile_image":null,"twitter":"@gojektech","facebook":null,"website":"http://www.gojek.io"}],"primary_author":{"name":"Gojek","slug":"gojek","bio":null,"profile_image":null,"twitter":"@gojektech","facebook":null,"website":"http://www.gojek.io"},"primary_tag":{"name":"Tech","slug":"tech","description":"Learnings from technical challenges solved at Gojek, how-tos, and programming tips.","feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Tech","slug":"tech","description":"Learnings from technical challenges solved at Gojek, how-tos, and programming tips.","feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"By Soham Kamani\n\nThe single responsibility principle is one of the most tried-and-tested tenets\nof software design. Every module or class should do one thing, and do it well.\nWe found this principle was applicable, and incredibly important, while\ndesigning our systems.\n\nAbout a year ago, we released a new chat service (which we internally called \nIcebreaker). It allowed our users to communicate with drivers through the app\nitself, rather than use SMS (which cost both the driver and customer money).\n\nHowever, all was not well. For numerous reasons, the service gave us a lot of\nissues and late night pagers. This post details the lessons we learnt, and some\nof the decisions we took to make this service more reliable.\n\nThe Problem(s)\nIn a nutshell, Icebreaker depended on too many other services to function\nproperly. Let’s look at some of the tasks Icebreaker performed in order to\ncreate a channel:\n\n 1. Authorise the API call: This made a call to our authentication service.\n 2. Fetch the customer profile: This required an HTTP call to our customer\n    service.\n 3. Fetch the drivers’ profile: This required an HTTP call to our driver\n    service.\n 4. Verify if the customer-driver pair are in an active order: This made a call\n    to our active booking storage service.\n 5. Create the channel.\n\nIf any of these services failed, Icebreaker would fail as well.\n\nSimultaneous dependence on multiple services ensures that the dependent service\nis less stable than any of themEven if we could ensure 99% uptime for all\nservices in question, that still means the chances of all of them being up at\nthe same time was 96%.\n\nP(icebreaker active) = P(customer service active) * P(driver service active) *\nP(authentication service active) * P(active booking storage active) = 0.99 *\n0.99 * 0.99 * 0.99 ~= 0.96\n\nThis means our downtime has increased four times over (4%, as opposed to 1%).\n\nNot my job\nWhen a service starts to do too many things, it’s bound to fail sooner or later.\nIn this case, Icebreaker’s job was to create a channel between a customer and a\ndriver. However, it was doing all this extra stuff: like authentication,\nverification, and profile retrieval. 🤦‍♂\n\nLet’s take a look at the changes we made to get rid of each dependency:\n\nAuthentication\nEvery API call arriving to Icebreaker came with an API token which needed\nauthentication. To solve this, we added a Kong [https://konghq.com/] API\ngateway. This authenticated all requests and added information about the\nauthenticated user within the API headers.\n\nNow, every request arriving to Icebreaker was authenticated.\n\n> Key takeaway: Tell, don’t ask. The requests coming from the API gateway told the\nservice that they were authenticated, rather than Icebreaker having to ask\nanother service.\nProfile retrieval\nIn order to create a channel, we needed a piece of information called the ‘chat\ntoken’ for each user. This was stored in the customer service for the customer,\nand the driver service for the driver.\n\nSince Icebreaker was the only service using this token, we moved these tokens to\nit, and removed them from the customer and driver services.\n\nNow,Icebreaker had all the information it needed in its own database, which was\na more reliable source of truth as compared to a whole other HTTP service.\n\n> Key takeaway: If your service is the only one using any piece of information, it\nshould reside within the service itself\nActive booking storage\nIcebreaker used to create a channel on-demand every time the user hit its\nchannel creation API. This on-demand creation required us to verify that an\nactive booking existed, for which the user needed to create a channel. After\nall, it didn’t make sense to create a channel when the parties involved did not\nhave an order with each other.\n\nTo fix this, we moved to an asynchronous architecture for channel creation.\nInstead of on-demand channel creation, we made use of GO-JEKs data pipeline\n[https://blog.gojekengineering.com/data-infrastructure-at-go-jek-cd4dc8cbd929],\nthat published events every time a booking was made. Icebreaker now consisted of\ntwo components: the worker and the server.\n\n 1. The worker consumed booking events every time they were made. It then\n    created a channel between the customer and driver in the booking, and stored\n    the channel information on a Redis cache.\n 2. The server served channel creation requests as before. Only, this time, the\n    channels were already created and cached, along with the order number.\n    \n\nSo, instead of on demand channel creation, the channels were created and stored\nbeforehand. Since we were consuming booking events from our own data pipeline,\nthere was no need to verify whether the booking was genuine or not.\n\n> Key takeaway: Again, tell, don’t ask. The events coming from our data pipeline\ntold Icebreaker that the bookings were genuine. This meant it could create the\nchannel, instead of hitting a service to verify the authenticity of the booking.\nResults\nNow Icebreaker did only what it was truly meant to do: create channels.\n\nSince we removed dependencies on most external systems, we no longer had to\nworry about one system failure causing Icebraker to malfunction. The load on the\nexternal services also reduced, since Icebreaker was no longer using their\nendpoints for channel creation.\n\nMoving to the asynchronous architecture also led to a drastic reduction in\nresponse time, from ~200ms to ~10ms, since we were pre-creating and caching\nchannels for every order.\n\nThe takeaways we got from this experience conform with the single responsibility\nprinciple. In the end, it’s always better to ask ourselves: “Can this service do\nless?”\n\n\n--------------------------------------------------------------------------------\n\nWant our stories in your inbox? Sign up for our newsletter!\n[https://mailchi.mp/go-jek/gojek-tech-newsletter]","html":"<p>By Soham Kamani</p><p>The single responsibility principle is one of the most tried-and-tested tenets of software design. Every module or class should do one thing, and do it well. We found this principle was applicable, and incredibly important, while designing our systems.</p><p>About a year ago, we released a new chat service (which we internally called <strong><strong>Icebreaker</strong></strong>). It allowed our users to communicate with drivers through the app itself, rather than use SMS (which cost both the driver and customer money).</p><p>However, all was not well. For numerous reasons, the service gave us a lot of issues and late night pagers. This post details the lessons we learnt, and some of the decisions we took to make this service more reliable.</p><h1 id=\"the-problem-s-\">The Problem(s)</h1><p>In a nutshell, Icebreaker depended on too many other services to function properly. Let’s look at some of the tasks Icebreaker performed in order to create a channel:</p><ol><li>Authorise the API call: This made a call to our authentication service.</li><li>Fetch the customer profile: This required an HTTP call to our customer service.</li><li>Fetch the drivers’ profile: This required an HTTP call to our driver service.</li><li>Verify if the customer-driver pair are in an active order: This made a call to our active booking storage service.</li><li>Create the channel.</li></ol><figure class=\"kg-card kg-image-card\"><img src=\"https://miro.medium.com/max/1304/1*oSRgws5JNm767tOTJfq7EA.png\" class=\"kg-image\"></figure><p><strong><strong>If any of these services failed, Icebreaker would fail as well.</strong></strong></p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://miro.medium.com/max/1304/1*tpBpiBUBVK-N0chl5fkLGQ.png\" class=\"kg-image\"><figcaption>Simultaneous dependence on multiple services ensures that the dependent service is less stable than any of them</figcaption></figure><p>Even if we could ensure 99% uptime for all services in question, that still means the chances of all of them being up at the same time was 96%.</p><p><code>P(icebreaker active) = P(customer service active) * P(driver service active) * P(authentication service active) * P(active booking storage active) = 0.99 * 0.99 * 0.99 * 0.99 ~= 0.96</code></p><p>This means our downtime has increased four times over (4%, as opposed to 1%).</p><h1 id=\"not-my-job\">Not my job</h1><p>When a service starts to do too many things, it’s bound to fail sooner or later. In this case, Icebreaker’s job was to create a channel between a customer and a driver. However, it was doing all this extra stuff: like authentication, verification, and profile retrieval. 🤦‍♂</p><p>Let’s take a look at the changes we made to get rid of each dependency:</p><h2 id=\"authentication\">Authentication</h2><p>Every API call arriving to Icebreaker came with an API token which needed authentication. To solve this, we added a <a href=\"https://konghq.com/\" rel=\"noopener\">Kong</a> API gateway. This authenticated all requests and added information about the authenticated user within the API headers.</p><figure class=\"kg-card kg-image-card kg-width-wide\"><img src=\"https://miro.medium.com/max/1634/1*2d7v8u_WVx7YDowNapZGNQ.png\" class=\"kg-image\"></figure><p>Now, every request arriving to Icebreaker was authenticated.</p><blockquote><em><em><strong><strong><em>Key takeaway</em></strong></strong><em>: Tell, don’t ask. The requests coming from the API gateway told the service that they were authenticated, rather than Icebreaker having to ask another service.</em></em></em></blockquote><h2 id=\"profile-retrieval\">Profile retrieval</h2><p>In order to create a channel, we needed a piece of information called the ‘chat token’ for each user. This was stored in the customer service for the customer, and the driver service for the driver.</p><figure class=\"kg-card kg-image-card kg-width-wide\"><img src=\"https://miro.medium.com/max/1634/1*dKBOVH4ODILeTSqgQIazcw.png\" class=\"kg-image\"></figure><p>Since Icebreaker was the only service using this token, we moved these tokens to it, and removed them from the customer and driver services.</p><figure class=\"kg-card kg-image-card kg-width-wide\"><img src=\"https://miro.medium.com/max/1634/1*eXYrRFGNnEPqv0nvbwjbIA.png\" class=\"kg-image\"></figure><p>Now,Icebreaker had all the information it needed in its own database, which was a more reliable source of truth as compared to a whole other HTTP service.</p><blockquote><em><em><strong><strong><em>Key takeaway</em></strong></strong><em>: </em><em>If your service is the only one using any piece of information, it should reside within the service itself</em></em></em></blockquote><h1 id=\"active-booking-storage\">Active booking storage</h1><p>Icebreaker used to create a channel on-demand every time the user hit its channel creation API. This on-demand creation required us to verify that an active booking existed, for which the user needed to create a channel. After all, it didn’t make sense to create a channel when the parties involved did not have an order with each other.</p><p>To fix this, we moved to an asynchronous architecture for channel creation. Instead of on-demand channel creation, we made use of GO-JEKs <a href=\"https://blog.gojekengineering.com/data-infrastructure-at-go-jek-cd4dc8cbd929\" rel=\"noopener\">data pipeline</a>, that published events every time a booking was made. <strong><strong>Icebreaker now consisted of two components: the worker and the server.</strong></strong></p><ol><li>The worker consumed booking events every time they were made. It then created a channel between the customer and driver in the booking, and stored the channel information on a Redis cache.</li><li>The server served channel creation requests as before. Only, this time, the channels were already created and cached, along with the order number.<br></li></ol><figure class=\"kg-card kg-image-card kg-width-wide\"><img src=\"https://miro.medium.com/max/3283/1*hNR_iSrTKkyvUhwMviHX_g.png\" class=\"kg-image\"></figure><p>So, instead of on demand channel creation, the channels were created and stored beforehand. Since we were consuming booking events from our own data pipeline, there was no need to verify whether the booking was genuine or not.</p><blockquote><em><em><strong><strong><em>Key takeaway</em></strong></strong><em>: Again, tell, don’t ask. The events coming from our data pipeline told Icebreaker that the bookings were genuine. This meant it could create the channel, instead of hitting a service to verify the authenticity of the booking.</em></em></em></blockquote><h1 id=\"results\">Results</h1><p>Now Icebreaker did only what it was truly meant to do: create channels.</p><p>Since we removed dependencies on most external systems, we no longer had to worry about one system failure causing Icebraker to malfunction. The load on the external services also reduced, since Icebreaker was no longer using their endpoints for channel creation.</p><p>Moving to the asynchronous architecture also led to a drastic reduction in response time, from ~200ms to ~10ms, since we were pre-creating and caching channels for every order.</p><p>The takeaways we got from this experience conform with the single responsibility principle. In the end, it’s always better to ask ourselves: <strong><strong><em><em>“Can this service do less?”</em></em></strong></strong></p><hr><p>Want our stories in your inbox? <a href=\"https://mailchi.mp/go-jek/gojek-tech-newsletter\">Sign up for our newsletter!</a><br></p>","url":"https://gojek-ghost.zysk.in/applying-the-single-responsibility-principle-to-microservices/","canonical_url":null,"uuid":"8bb46a92-34cc-4bf4-a26e-65dc26a77873","page":null,"codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5ec2af8a7aa22c4066f83abe","reading_time":4}}]}},"pageContext":{"slug":"tech","limit":12,"skip":0,"numberOfPages":1,"humanPageNumber":1,"prevPageNumber":null,"nextPageNumber":null,"previousPagePath":null,"nextPagePath":null}}}